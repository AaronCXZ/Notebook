## 12.1 函数上移（Pull Up Method）

1. 名称

2. 一个简单的速写

```javascript
class Employee {...}
class Salesman extends Employee{
    get name(){...}
}
class Engineer extends Employee{
    get name(){...}
}
```

重构为：

```javascript
class Employee {
    get name(){...}
}
class Salesman extends Employee{}
class Engineer extends Employee{}
```

3. 动机

避免重复代码时很重要的。

4. 做法

- 检查待提升函数，确定它们时完全一致的
- 检查函数体内引用的所有函数调用和字段都能从超类中调用到
- 如果待提升函数的签名不同，使用改变函数声明将那些签名都修改为你想要在超类中使用的签名
- 在超类中新建一个函数，将某一个待提升函数的代码复制到其中
- 执行静态检查
- 移除一个待提升的子类函数
- 测试
- 逐一移除待提升的子类函数，直到只剩下超类中的函数为止

5. 范例

```javascript
class Employee extends Party {
    get annualCost(){
        return this.monthlyCost * 12;
    }
}
class Department extends Party {
    get totalAnnualCost(){
        return this.monthlyCost * 12;
    }
}
```

两个函数都引用了monthltCost属性，首先改变函数声明

```javascript
class Employee extends Party {
    get annualCost(){
        return this.monthlyCost * 12;
    }
}
class Department extends Party {
    get annualCost(){
        return this.monthlyCost * 12;
    }
}
```

然后将其中一个子类的函数复制到超类中

```javascript
class Party {
    get annualCost(){
        return this.monthlyCost * 12;
    }    
}
```

## 12.2 字段上移（Pull Up Field）

1. 名称

2. 一个简单的速写

```javascript
class Employee {}
class Salesman extends Employee {
    private String name;
}
class Engineer extends Employee {
    private String name;
}
```

重构为：

```javascript
class Employee {
    protected String name;
}
class Salesman extends Employee {...}
class Engineer extends Employee {...}
```

3. 动机

首先它取出了重复的数据声明；其次它使我可以将使用该字段的行为从子类移至超类，从而去除重复的行为

4. 做法

- 针对待提升之字段，检查它们的所有使用点，确认它们以同样的方式被使用
- 如果这些字段的名称不同，先使用变量改名为它们取个相同的名字
- 在超类中新建一个字段
- 移除子类中的字段
- 测试

5. 范例

## 12.3 构造函数本体上移（Pull Up Constructor Body）

1. 名称

2. 一个简单的速写

  ```javascript
  class Party {...}
  class Employee extends Party {
      constructor(name, id, monthlyCost){
          super();
          this._id = id;
          this._name = name;
          this,_monthlyCost = monthlyCost;
      }
  }
  ```

重构为：

```javascript
class Party {
    constructor(name){
        this._name = name;
    }
}
class Employee extends Party {
    constructor(name, id, monthlyCost){
        super(name);
        this._name = name;
        this,_monthlyCost = monthlyCost;
    }
}
```

3. 动机

4. 做法

- 如果超类还不存在构造函数，首先为其定义一个。确保让子类调用超类的构造函数
- 使用移动语句将子类中构造函数中的公共语句移动到超类的构造函数调用语句之后
- 逐一移除子类间的公共代码，将其提升至超类构造函数中。对于公共代码中引用到的变量，将其作为参数传递给吵了的构造函数
- 测试
- 如果存在无法简单提升至超类的公共代码，先应用提炼函数，再利用函数上移提升之

5. 范例

- 范例一：

```javascript
class Party{}
class Employee extends Party {
    constructor(name, id, monthlyCost){
        super();
        this._id = id;
        this._name = name;
        this,_monthlyCost = monthlyCost;
    }
}
class Department extends Party {
    constructor(name, staff){
        super();
        this._name = name;
        this._staff = staff;
    }
}
```

先用移动语句将Employee中的赋值语句移动到super()调用后面

```javascript
class Employee extends Party {
    constructor(name, id, monthlyCost){
        super();
        this._name = name;
        this._id = id;
        this,_monthlyCost = monthlyCost;
    }
}
```

在超类中使用构造函数，并将name作为参数传递

```javascript
class Party{
    constructor(name){
        this._name = name;
	}
}
class Employee extends Party {
    constructor(name, id, monthlyCost){
        super(name);
        this._id = id;
        this,_monthlyCost = monthlyCost;
    }
}
class Department extends Party {
    constructor(name, staff){
        super(name);
        this._staff = staff;
    }
}
```

- 范例二

```javascript
class Employee {
    constructor(name){...}
    get isPrivileged(){...}
    assignCar(){...}
}
class Manager extends Employee {
    constructor(name, grade){
        super(name);
        this._grade = grade;
        if (this.isPrivileged) this.assignCar();
    }
    get isPrivileged(){
        return this._grade > 4;
    }
}
```

无法简单的将isPrivileged提升至超类，先对公共代码使用提炼函数

```javascript
class Manager extends Employee {
	constructor(name, grade){
        super(name);
        this._grade = grade;
        this.finishConstruction();
    }
    get isPrivileged(){
        return this._grade > 4;
    }
    finishConstruction(){
        if (this.isPrivileged) this.assignCar();
    }
} 
```

然后将提炼得到的函数上移至超类

```javascript
class Employee {
    constructor(name){...}
    get isPrivileged(){...}
    assignCar(){...}
    finishConstruction(){
        if (this.isPrivileged) this.assignCar();
    }
}
```











































