#### 散列思想
- 散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。
#### 散列函数
1. 散列函数计算得到的散列值是一个非负整数
2. 如果 key1 == key2，那么 hash(key1) == hash(key2)
3. 如果 key1 != key2，那么 hash(key1) != hash(key2) 
#### 散列冲突
1. 开发寻址法：如果出现散列冲突，我们就重新探测一个空间位置，将其插入
    1. 线性探测：当我们向散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。
    2. 二次探测：探测是步长为二次方，即hash(key)+0，hash(key)+1^2，hash(key)+2^2.........
    3. 二重探测：使用多个散列函数，如果第一个散列函数的值被占用了，再使用第二个散列函数，依次类推，直到找到空闲的存储位置。
    - 装载因子：填入表中的元素个数/散列表的长度。
    - 装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。
2. 链表法：在散列表中，每个桶或槽会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。
#### 如何设计散列函数
- 散列函数的设计不能太复杂
- 散列函数生成的值要尽可能随机并且均匀分布
#### 装载因子过大了怎么办
动态扩容
#### 如何避免低效的扩容
- 为了解决一次性扩容耗时过多的情况，我们可以将扩容操作穿插在插入操作的过程中，分批完成，当装载因子触达阈值之后，我们只申请新空间，但并不将老的数据搬移到性散列表中，当有新数据要插入时，我们蒋新数据插入性散列表中，并从老的散列表中拿出一个数据放入到新散列表中。每次插入一个数据到散列表，我们都重复上面的过程。
- 对于查询操作，为了兼容新、老散列表中的数据，我们先从性散列表中查找，如果没有找到，再去老的散列表中查找
#### 如何选择冲突解决方法
1. 开放寻址法：
   - 优点：
      1. 散列表中的数据都存储再数组中，可以有效的利用CPU缓存加快查询速度
      2. 序列化起来比较简单
   - 缺点：
     1. 删除数据时比较麻烦
     2. 冲突的代价更高
   - 总结：当数据量比较小、装载因子小的时候，适合采用开放寻址法
2. 链表法：
    - 优点：
      1. 对内存的利用率高
      2. 对大装载因子容忍度更高
    - 缺点：
      1. 对于比较小的对象存储比较消耗内存
      2. 链表中的节点时零散分布在内才中的，对CPU缓存是不友好的
    - 总结：基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。
#### 工业级散列表设计
1. 要求：
   1. 支持快速地查询、插入、删除操作
   2. 内存占用合理，不能浪费过多的内存空间
   3. 性能稳定，极端情况下，散列表的性能也不能退化到无法接受的情况
2. 设计思路：
   1. 设计一个合适的散列函数
   2. 定义装载因子阈值，并设计动态扩容策略
   3. 选择合适的散列冲突解决方法
#### LRU缓存淘汰算法
- 使用双向链表存储数据，链表中的每个节点处理存储数据data、前驱指针prev、后继指针next之外，还新增了一个特殊的字段hnext、
- 前驱和后继指针是为了将节点串在双向链表中，hnext指针是为了将节点串在散列表的拉链中。
- 查找：在散列表中找到数据O(1)，然后将数据移动到链表的尾部
- 删除：在散列表中找到数据O(1)，然后在双向链表中通过前驱指针获取前驱节点删除O(1)
- 添加：先查找数据是否已经存在在缓存中，如果已经存在，将其移动到双向链表的尾部；如果不存在，看缓存是否已满。如果满了，删除双向链表的头部节点，然后将数据放到双向链表的尾部；如果没有满，就直接将数据放到链表的尾部。
#### Redis有序集合
- Redis有序集合的操作：
  - 添加一个新成员对象
  - 按照键值来删除一个成员对象
  - 按照键值来存在一个成员对象
  - 按照分值区间存在数据，比如查找积分在[100,356]之间的成员对象
  - 按照分值从小到大排序成员变量
- 如果仅仅按照沉淀对象组织跳表的结构，那安装键值来删除、查询成员对象就会很慢，解决方法就是再安装键值构建一个散列表，这个安装key来删除、查找一个成员对象的时间复杂度就编程了O(1)，同时借助跳表结构，其他操作也非常高效。
#### Java LinkedHashMap
- 通过散列表和双向链表组合在一起实现的
- Linked是指双向链表
