### 如何分析一个排序算法
##### 排序算法的执行效率
1. 最好情况、最坏情况、平均情况时间复杂度
    1. 为了好对比
    2. 有序度不同影响排序的执行时间
2. 时间复杂度的系数、常数、低阶
    - 实际应用中很多都是规模较小的数据，需要考虑
3. 比较次数或交换（或移动）次数
    - 基于比较的排序会涉及元素的比较和元素的交换或移动，需要考虑次数
##### 排序算法的内存消耗
- 原地排序算法：特指空间复杂度时O(1)的排序算法
##### 排序算法的稳定性
- 稳定性排序算法：如果待排序的序列中存在值相等的元素，经过排序之后，相等的元素之间的先后顺序不变
### 冒泡排序
- 只会操作相邻的两个数据；
- 每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求
- 如果不满足就让他俩互换
- 一次冒泡会让至少一个元素移动到它应该在的位置，重复n次，就完成了n个数据的排序工作
- 当某次冒泡操作已经没有数据交换时，说明已经达到了完全有序，不用再继续执行后续的冒泡操作了
1. 最好时间复杂度：O(n)
2. 最坏时间复杂度：O(n^2)
3. 平均时间复杂度：O(n^2)
4. 空间复杂度：O(1),原地排序
### 插入排序
- 首先将数组中的数据分为两个区间，已排序区间和未排序区间
- 初始已排序区间只有一个元素，即数组的第一个元素
- 取未排序区间的元素，在已排序区间中找到合适的位置将其插入，并保证已排序区间的数据一直有序
- 重复这个过程，直到未排序区间中的元素为空，算法结束。
1. 最好时间复杂度：O(n)
2. 最坏时间复杂度：O(n^2)
3. 平均时间复杂度：O(n^2)
4. 空间复杂度：O(1),原地排序
### 选择排序
- 分为已排序区间和未排序区间
- 每次从未排序区间中找到最小的元素，将其放到已排序区间的末尾
- 不稳定排序算法
2. 最好时间复杂度：O(n^2)
3. 最坏时间复杂度：O(n^2)
4. 平均时间复杂度：O(n^2)
5. 空间复杂度：O(1),原地排序
