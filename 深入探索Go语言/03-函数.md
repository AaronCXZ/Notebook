### 函数

从代码结构来看，层层函数调用就是一个后进先出的过程，与数据结构中的入栈出栈的操作完全一致，所以非常适合用栈来管理好书的局部变量等数据

栈指针SP以及入闸出栈对应的指令，`CALL`指令和RET指令

1. `f1()`函数的调用由`CALL`指令实现。
2. `CALL`指令会先把下一条指令的地址压入栈中，这就是所谓的返回地址。
3. 然后会跳转到`f1()`函数的地址处执行
4. 当`f1()`函数执行完成之后会返回`CALL`指令压栈的返回地址处继续执行
5. 由于`CALL`指令引发了入栈操作和指令跳转，所以`SP`和`IP`寄存器的值都发生了改变
6. 当`f1()`函数执行到最后时会有一条`RET`指令，`RET`指令会从栈上弹出返回地址，然后跳转到该地址处继续执行

### 栈帧

在一个函数的调用过程中，栈不只是用来返回地址，还被用来传递参数和返回值，以及分配函数局部变量等。

随着每一次函数调用，后悔在栈上分配一段内存，用来存放这些信息，这段内存就是所谓的函数栈帧

#### 栈帧布局

实际管理栈帧的是函数自身的代码，也就是说由编译器生产的指令负责栈帧的扽配与释放

栈帧的布局也是由编译器在编译阶段确定的，其依据就是函数代码

函数栈帧分布：

1. `return address`：函数返回地址，占有一个指针大小的空间。实际上是在函数被调用时由`CALL`指令制动压栈的，并非由被调用函数分配
2. caller's BP：调用者的栈帧基址，栈用一个指针大小的空间。用来将调用路径上所有的栈帧连成一个链表，方便回溯之类的操作，只在部分平台结构上存在
3. locals：局部变量区间，占有若干机器字，用来存放函数的局部变量
4. args to caller：调用传参区域，占有若干机器字。按照当前函数调用的所有函数中返回值加上参数所占用的最大空间分配

所以只有`return address`是一定会存在，其它三个区域会根据实际情况进行分析

#### 调用规约

Go语言普通函数的调用约定如下：

1. 返回值的参数都通过栈传递，对应的栈空间由调用者负责分配和释放
2. 返回值和参数在栈上的布局等价于两个struct，struct的起始地址按照平台机器字长对齐

从Go1.17版本开始在部分架构上实现了基于寄存器的参数传递，提升了性能。但是寄存器数量有限，参数过多时，只能部分参数分配在寄存器上，其余参数分配在栈上。例如使用9个通用寄存器对参数进行优化，最多只能传递9个机器字节大小，而不是9个参数，像string会占有2个机器字，切片会占用3个机器字。即便如此，对于大部分函数来讲都已经足够了，所以整体性能提升很可观。

### 逃逸分析

如果一个函数把自己栈帧上某个局部变量的地址作为返回值返回，按照前面对栈帧布局的分析，局部变量应该分配在栈帧的locals区间。函数返回后，它的栈帧随即销毁，返回的局部变量地址会变成一个悬挂指针，caller中对该地址进行的所有读写都会不合法，会造成程序逻辑错误甚至崩溃。但是实际上并不是。

当函数局部变量的生命周期超过函数栈帧的生命周期时，编译器把该局部变量由栈分配改为堆分配，即变量从栈上逃逸到堆上。

#### 不逃逸分析

如果对局部变量进行区地址操作会被转换为new()函数调用，那就不用进行所谓的逃逸分析了

事实上，只有代码逻辑允许，编译器总是倾向于把变量分配在栈上，因为不分配在堆上更高效

#### 不逃逸判断

编译器只有在能够确定变量没有逃逸的情况下，才会将其分配到栈上，在能够确定变量已经逃逸或无法确定到底有没有淘气的情况下，都要按照已经逃逸来处理

### Function Value

当把一个函数赋值给某个变量后，这个变量就被称为`Function Value`

`Function Value`不直接指向目标函数，而是一个目标函数的指针

### 闭包

闭包的典型场景就是在某个函数内定义了另一个函数，内层函数使用了外层函数的局部变量，并且内层函数最终被外层函数作为返回值返回

```go
struct {
  F uintptr // 存储目标函数的地址，称为闭包函数 
  n int     // 闭包的捕获列表，也就是内层函数中用到的所有定义的外层函数中的变量
}
```

编译器识别出了闭包这种模式，并自动定义了这个struct类型进行支持，把这种struct称为闭包对象

```go
func newobject(typ *_type) unsafe.Pointer
```

Go程序在运行阶段会通过`runtime.newobject()`函数动态分配闭包对象。该函数的返回值是个指针，也就是新分配的对象的地址，参数是个`_type`类型的指针

这个`_type`是个`struct`，在runtime中被用来描述一个数据类型，通过它可以找到目标数据类型的大小，对齐边界，类型名称等，称为类型元数据。Go语言的反射机制以来这些类型元数据

```go
package main

import (
	"reflect"
	"unsafe"

	"github.com/fengyoulin/hookingo"
)

var hno hookingo.Hook

//go:linkname newobject runtime.newobject
func newobject(typ unsafe.Pointer) unsafe.Pointer

func fno(typ unsafe.Pointer) unsafe.Pointer {
	t := reflect.TypeOf(0)
	(*(*[2]unsafe.Pointer)(unsafe.Pointer(&t)))[1] = typ
	println(t.String())
	if fn, ok := hno.Origin().(func(typ unsafe.Pointer) unsafe.Pointer); ok {
		return fn(typ)
	}
	return nil
}

// 创建一个闭包，make closure
func mc(start int) func() int {
	return func() int {
		start++
		return start
	}
}

func main() {
	var err error
	hno, err = hookingo.Apply(newobject, fno)
	if err != nil {
		panic(err)
	}
	f := mc(10)
	println(f())
}
```

#### 调用闭包

调用者负责在调用之前把闭包对象的地址存储到DX寄存器中。调用者不必区分是不是闭包，有没有捕获列表，如果`Function Value`的背后不是闭包这个地址就不会被用到



















