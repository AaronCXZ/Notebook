#### 树
- 节点：每个元素我们叫做节点
- 父子关系：用来连接相邻节点之间的关系我们叫做父子关系
- 兄弟关系：拥有同一个父节点的节点称为兄弟节点
- 根节点：没有父节点的节点称为根节点
- 叶子节点：没有子节点的节点称为叶子节点
- 节点的高度：节点到叶子节点的最长路径（边数）
- 节点的深度：根节点到这个节点所经历的边的个数
- 节点的层数：节点的深度+1
- 树的高度：根节点的高度
#### 二叉树
- 每个节点最多有两个子节点，分别为左子节点和右子节点
- 满二叉树：叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点
- 完全二叉树：叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都达到最大
- 二叉树的存储：
  - 基于指针或者引用的二叉链式存储法
  - 基于数组的顺序存储法(完全二叉树存储比较节省空间，其它二叉树浪费空间)
#### 二叉树的遍历
- 前序遍历：对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树
- 中序遍历：对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树
- 后序遍历：对于树中的任意节点来说，先打印它的左子树，然后再打印它的左子树，最后打印这个节点本身
- 前、中、后序遍历是打印本身相对于左右子节点的顺序
- 二叉树的遍历时间复杂度是O(n)
#### 二叉查找树
- 也叫二叉搜索树，是为了实现快速查找而生的，还支持快速插入、删除一个数据
- 二叉查找树要求：在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都要大于这个节点的值
- 查找：先取根节点，如果它等于我们要查找的数据，那就返回，如果要查找的数据比根节点的值小，那就在左子树中递归查找；如果要查找的数据比根节点的值大，那就在右子树中递归查找
- 插入：如果要插入的数据比节点的数据大，并且节点的右子树为空，那就将新数据直接插到右子节点的位置；如果不为空，就再递归遍历右子树，查找插入位置。同理，如果要插入的数据比节点数值小，并且节点的左子树为空，就将数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置
- 删除：
  1. 如果要删除的节点没有子节点，我们只需要直接将父节点中，指向要删除节点的指针置为null。
  2. 如果要删除的节点只有一个子节点，我们只需要更新父节点中指向要删除节点的指针，让它指向要删除节点的子节点就可以了
  3. 如果要删除的节点右两个子节点，我们需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上。然后再删除掉这个最小节点
- 其他操作：快速地查找最大节点和最小节点
- 中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度为O(n)，非常高效，因此又叫作二叉排序树
#### 支持重复数据的二叉查找树
- 通过链表和支持动态扩容的数组等数据结构，把值相同的数据存储在同一个节点上
- 要插入的数据相同时，我们将这个要插入的数据放到这个节点的右子树。此时查找数据时遇到值相同的节点并不停止查找操作，而是继续在右子树中查找，直到遇到叶子节点才停止，这样就等于把要查找值的所有节点都找出来了；对于删除也是要先查找到要删除的所有节点，然后执行删除操作依次删除
#### 二叉查找树的时间复杂度
- 极度不平衡的二叉查找树，也就是退化成链表的二叉查找树时间复杂度为O(n)
- 时间复杂度是O(height)，即跟树的高度有关
- 平衡二叉树的时间复杂度是O(logn)
#### 二叉查找树对比散列表的优势
1. 散列表中的数据是无序存储的，二叉查找树使用中序遍历可以在O(n)的时间复杂度内输出有序的数据序列
2. 散列表的扩容耗时很多，而且当遇到散列冲突时，性能不稳定。在工程中最常使用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在O(logn)
3. 尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量并不一定比logn小
4. 散列表的构造比二叉查找树要复杂，需要考虑很多东西，比如散列函数的设计。冲突解决办法。扩容。缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定
5. 为了避免过多的散列冲突，散列表的装载因子不能太大。