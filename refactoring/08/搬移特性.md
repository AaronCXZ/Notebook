## 8.1 搬移函数（Move Function）

1. 名称

2. 一个简单的速写

```javascript
class Account {
    get overdraftCharge(){...}
}
```

重构为：

```javascript
class AccountType {
    get overdraftCharge(){...}
}
```

3. 动机

最直接的一个动因：它频繁引用其他上下文中的元素，而对自身上下文中的元素却关心甚少。

4. 做法

- 检查函数在当前上下文里引用的所有程序元素（包括变量和函数），考虑是否需要将它们一并搬移
- 检查待搬移函数是否具备多态性
- 将函数复制一份到目标上下文中，调整函数，使它能适应新家
- 执行静态检查
- 设法从源上下文中正确引用目标函数
- 修改源函数，使之成为一个纯委托函数
- 测试
- 考虑对源函数使用内联函数

5. 范例

- 范例一：搬移内嵌函数至顶层：

```javascript
function trackSummary(points){
    const totalTime = calculateTime();
    const totalDistance = calculateDistance();
    const pace = totalTime / 60 / totalDistance;
    return {
        time: totalTime,
        distance: totalDistance,
        pace: pace
    };
    function calculateDistance(){
        let result = 0;
        for (let i = 1; i < points.length; i++) {
            result += distance(points[i-1], points[i]);
        }
        return result;
    }
    function distance(p1, p2){...}
    function radlans(degrees){...}
    function calculateTime(){...}
}
```

将函数calculateDistance搬移到顶层，单独的计算轨迹的距离

```javascript
function trackSummary(points){
    const totalTime = calculateTime();
    const totalDistance = calculateDistance();
    const pace = totalTime / 60 / totalDistance;
    return {
        time: totalTime,
        distance: totalDistance,
        pace: pace
    };
    function calculateDistance(){
        let result = 0;
        for (let i = 1; i < points.length; i++) {
            result += distance(points[i-1], points[i]);
        }
        return result;
    }
    function distance(p1, p2){...}
    function radlans(degrees){...}
    function calculateTime(){...}
}
function top_calculateDistance(){
	let result = 0;
    for (let i = 1; i < points.length; i++) {
		result += distance(points[i-1], points[i]);
    }
    return result;
}                    
```

处理新函数的未定义变量

```javascript
function top_calculateDistance(points){
	let result = 0;
    for (let i = 1; i < points.length; i++) {
		result += distance(points[i-1], points[i]);
    }
    return result;
    function distance(p1, p2){...}
    function radlans(degrees){...}
}   
```

在原calculateDistance函数体内调用top_calculateDistance函数

```javascript
function trackSummary(points){
    const totalTime = calculateTime();
    const totalDistance = calculateDistance();
    const pace = totalTime / 60 / totalDistance;
    return {
        time: totalTime,
        distance: totalDistance,
        pace: pace
    };
    function calculateDistance(){
        top_calculateDistance(points);
    }
    function calculateTime(){...}
}
```

移除源函数

```javascript
function trackSummary(points){
    const totalTime = calculateTime();
    const totalDistance = top_calculateDistance(points);
    const pace = totalTime / 60 / totalDistance;
    return {
        time: totalTime,
        distance: totalDistance,
        pace: pace
    };
    function calculateTime(){...}
}
```

函数改名和内嵌变量

```javascript
function trackSummary(points){
    const totalTime = calculateTime();
    const pace = totalTime / 60 / totalDistance(points);
    return {
        time: totalTime,
        distance: totalDistance(points);
        pace: pace
    };
    function calculateTime(){...}
}
function totalDistance(points){
	let result = 0;
    for (let i = 1; i < points.length; i++) {
		result += distance(points[i-1], points[i]);
    }
    return result;
    function distance(p1, p2){...}
    function radlans(degrees){...}
} 
```

将distance函数和radlans函数也提升到顶层

```javascript
function trackSummary(points){...}
function totalDistance(points){...}
function distance(p1, p2){...}
function radlans(degrees){...}
```

- 范例二：在类之间搬移函数

```javascript
class Account {
    get bankCharge(){
        let result = 4.5;
        if (this._daysOverdrawn > 0) result += this.overdraftCharge;
        return result;
    }
    get overdraftCharge(){
        if (this.type.isPremium){
            const baseCharge = 10;
            if (this.daysOverdrawn <= 7)
                return baseCharge;
            else
                return baseCharge + (this.daysOverdrawn -7) * 0.05;
        }
        else
            return this.daysOverdrawn * 1.75;
    }
}
```

将overdraftCharge函数复制一份到AccountType类中

```javascript
class AccountType {
    overdraftCharge(daysOverdrawn){
        if (this.isPremium){
            const baseCharge = 10;
            if (this.daysOverdrawn <= 7)
                return baseCharge;
            else
                return baseCharge + (daysOverdrawn -7) * 0.05;
        }
        else
            return daysOverdrawn * 1.75;
    } 
}
```

原方法修改为一个委托调用

```javascript
class Account {
    get bankCharge(){
        let result = 4.5;
        if (this._daysOverdrawn > 0) result += this.overdraftCharge;
        return result;
    }
    get overdraftCharge(){
        return this.type.overdraftCharge(this.daysOverdrawn);
    }
}
```

内联函数overdraftCharge

```javascript
class Account {
    get bankCharge(){
        let result = 4.5;
        if (this._daysOverdrawn > 0) 
            result += this.type.overdraftCharge(this.daysOverdrawn);
        return result;
    }
}
```

将整个对象作为参数传递给overdraftCharge函数

```javascript
class Account {
    get bankCharge(){
        let result = 4.5;
        if (this._daysOverdrawn > 0) 
            result += this.type.overdraftCharge(this);
        return result;
    }
}
class AccountType {
    overdraftCharge(account){
        if (this.isPremium){
            const baseCharge = 10;
            if (this.daysOverdrawn <= 7)
                return baseCharge;
            else
                return baseCharge + (account.daysOverdrawn -7) * 0.05;
        }
        else
            return account.daysOverdrawn * 1.75;
    } 
}
```

## 8.2 搬移字段（Move Field）

1. 名称

2. 一个简单的速写

```javascript
class Customer {
    get plan(){return this._plan;}
    get diacountRate(){return this._diacountRate;}
}
```

重构为：

```javascript
class Costomer {
    get plan(){return this._plan;}
    get discountRate(){return this.plan.discountRate;}
}
```

3. 动机

数据结构才是一个健壮程序的根基。一个适应于问题域的良好数据结构，可以让行为代码变得跟简单明了。

4. 做法

- 确保源字段已经得到了良好的封装
- 测试
- 在目标对象上创建一个字段（及对应的访问函数）
- 执行静态检查
- 确保源对象里能够正常引用目标对象
- 调整源对象的访问函数，令其使用目标对象的字段
- 测试
- 移除源对象上的字段
- 测试

5. 范例

```javascript
class Customer {
    constructor(name, discountRate){
        this._name = name;
        this._discountRate = discountRate;
        this._contract = new CustomerContract(dateToday());
    }
    get discountRate(){return this._discountRate;}
    becomePreferred(){
        this._discountRate += 0.03;
    }
    applyDiscount(amount){
        return amount.subtract(amount.multiply(this._discountRate));
    }
}
class CustomerContract {
    constructor(startDate){
        this._startDate = startDate;
    }
}
```

将折扣率（discountRate）字段从Customer类中搬移到CustomerContract类中，先将对discountRate字段的访问封装起来

```javascript
class Customer {
    constructor(name, discountRate){
        this._name = name;
        this._setDiscountRate(discountRate);
        this._contract = new CustomerContract(dateToday());
    }
    get discountRate(){return this._discountRate;}
    _setDiscountRate(aNubmer) {this._discountRate = aNumber;}
    becomePreferred(){
        this._setDiscountRate(this.discountRate + 0.03);
    }
    applyDiscount(amount){
        return amount.subtract(amount.multiply(this.discountRate));
    }
}
```

在CustomerContract类中添加一个对应的字段和访问函数

```javascript
class CustomerContract {
    constructor(startDate, discountRate){
        this._startDate = startDate;
        this._discountRate = discountRate;
    }
    get discountRate(){return this._discountRate;}
    set discountRate(arg){this._discountRate = arg;} 
}
```

修改customer对新的访问函数：

```
class Customer {
    constructor(name, discountRate){
        this._name = name;
        this._setDiscountRate(discountRate);
        this._contract = new CustomerContract(dateToday(), discountRate);
    }
    get discountRate(){return this._contract.discountRate;}
    _setDiscountRate(aNubmer) {this._contract.discountRate = aNumber;}
    becomePreferred(){
        this._setDiscountRate(this.discountRate + 0.03);
    }
    applyDiscount(amount){
        return amount.subtract(amount.multiply(this.discountRate));
    }
}
```

范例二：搬移字段到共享对象

```javascript
class Account {
    constructor(number, type, interestRate){
        this._number = number;
        this._type = type;
        this._interestRate = interestRate;
    }
    get interestRate(){return this._interestRate;}
}
class AccountType {
    constructor(nameString){
        this._name = nameString;
    }
}
```

将intererestRate字段搬移到AccountType类中：

```javascript
class AccountType {
    constructor(nameString, interestRate){
        this._name = nameString;
         this._interestRate = interestRate;
    }
    get interestRate(){return this._interestRate;}
}
```

在Account类引入断言，确保出现异常的利率数据时能够及时发现。

```javascript
class Account {
    constructor(number, type, interestRate){
        this._number = number;
        this._type = type;
        assert(insertestRate === this._type.interestRate);
        this._interestRate = interestRate;
    }
    get interestRate(){return this._interestRate;}
}
```

让Account直接访问AccountType上的interestRate字段，并将原来的字段完全删除

```javascript
class Account {
    constructor(number, type, interestRate){
        this._number = number;
        this._type = type;
    }
    get interestRate(){return this._tinterestRate;}
}
```

























