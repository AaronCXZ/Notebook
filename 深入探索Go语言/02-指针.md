### 指针

地址：一个有效的地址就是一个无符号整型数值，运行阶段用来在进程的内存地址空间中确定一个位置

解引用：把地址存入某个通用寄存器，然后用作基地址进行寻址

1. 空指针异常：空指针即地址值为0的指针。
2. 野指针问题：一般是由于指针变量未初始化造成的。Go语言中声明的变量默认都会初始化为对应类型的零值，指针类型变量都会初始化为nil。
3. 悬指针问题：指程序过早地释放了内存，而后续代码又对已释放的内存进行访问，从而造成程序出现错误或异常

强制类型转换

```go
func convert(p *int) {
  q = (*int32)(unsafe.Pointer(p))   # 把指针的类型强制转换为i32
  *q = 0
}
```

两种不同类型指针间的转换需要用`unsafe.Pointer`作为中间类型，`unsafe.Pointer`可以和任意一种指针类型互相转换

```go
// 一个“任意类型”的定义
type ArbitraryType int
// 指针类型定义
type Pointer *ArbitraryType
// 3个工具函数原型（只有原型，没有实现）
func Sizeof(x ArbitraryType) uintptr
func Offsetof(x ArbitraryType) uintptr
func Alignof(x ArbitraryType) uintptr
```



unsafe 并不是一个真实的包，unsafe提供的这些功能不是标准库层面能够实现的。出于安全的考虑放到unsafe包

直接的任意操作内存的能力可以让程序员写出高效的代码，但也让编译器无法落实安全检查，从而使程序变得不安全

uintptr其实是uint，大小和当前平台的指针宽度一致

内存对齐：硬件的实现一般会将内存的读写对齐到数据总线的宽度，这样既可以降低硬件实现的复杂度，又可以提升传输的效率

Go语言的内存对齐规则考虑了两方面因素：

1. 数据类型自身的大小，复合类型会参考最大成员大小
2. 硬件平台机器字长

机器字长：计算机进行一次整数运算所能处理的二进制数据的位数

常见内置类型的大小和对齐边界

| 类型                  | 32位平台 | 32位平台 | 64位平台 | 64位平台 |
| :-------------------- | :------: | :------: | :------: | :------: |
|                       |   大小   | 对齐边界 |   大小   | 对齐边界 |
| bool                  |    1     |    1     |    1     |    1     |
| int8,uint8            |    1     |    1     |    1     |    1     |
| int16,uint16          |    2     |    2     |    2     |    2     |
| int32, uint32,float32 |    4     |    4     |    4     |    4     |
| int64 uint64,float64  |    4     |    4     |    8     |    8     |
| int, uint, uintptr    |    4     |    4     |    8     |    8     |
| complex64             |    8     |    4     |    8     |    4     |
| complex128            |    16    |    4     |    16    |    8     |
| string                |    8     |    4     |    16    |    8     |
| slice                 |    12    |    4     |    24    |    8     |
| map                   |    4     |    4     |    8     |    8     |

