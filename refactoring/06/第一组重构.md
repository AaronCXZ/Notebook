## 提炼函数（Extract Function）

1. 名称：提炼函数。反向重构：内联函数

2. 一个简单的速写

```javascript
function printOwing(invoice){
    printBanner();
    let outstanding = calculateOutstanding();
    
    // print details
    console.log(`name: ${invoice.sutomer}`);
    console.log(`amount: ${outstanding}`);
}
```
重构为：
```javascript
function printOwing(invoice) {
    printBanner();
    let outstanding = calculateOutstanding();
    printDetails(outstanding);

    function printDetails(outstanding) {
        console.log(`name: ${invoice.sutomer}`);
        console.log(`amount: ${outstanding});
    }
}
```


3. 动机

将意图与实现分开：如果需要花时间浏览一段代码才能弄清楚它到底在干什么，那么就应该将其提炼到一个函数中，并根据它所做的事为其命名。小函数得有个好名字才行，所以必须在命名上花心思。


3. 做法

- 创在一个新函数，根据这个函数的意图来对它命名（以它”做什么“来命名）
- 将待提炼的代码从源函数复制到新建的目标函数中。
- 仔细检查提炼出的代码，看看其中是否应用了作用域限于源函数、在提炼出的新函数中访问不到的变量。若是，以参数的形式将它们传递给新函数。
- 所有的变量都处理完之后，编译。
- 在源函数中，将被提炼代码段替换为目标函数的调用。
- 测试。
- 查看其它代码是否与被提炼的代码段相同或相似之处。如果有，考虑使用已函数调用取代内联代码令其调用提炼出的新函数。


3. 范例

范例一：没有局部变量

```javascript
function printOwing(invoice){
    let outstanding =0;
    console.log("***********************");
    console.log("**** Customer Owes ****");
	console.log("***********************");
    
    for (const o of invoice.orders) {
        outstanding += o.amount;
    }
    
    const today = Clock.today;
    invoice.dueDate = new Date(today.getFullYear(), today.getMonth(), today.getDate()+30);

    console.log(`name: ${invoice.customer}`);
    console.log(`amount: ${outstanding}`);
    console.log(`due: ${invoice.dueDate.toLocaleDateString()}`);
}
```

提炼“打印横幅”代码

```javascript
function printOwing(invoice){
    let outstanding =0;
    printBanner();
    
    for (const o of invoice.orders) {
        outstanding += o.amount;
    }
    
    const today = Clock.today;
    invoice.dueDate = new Date(today.getFullYear(), today.getMonth(), today.getDate()+30);

    console.log(`name: ${invoice.customer}`);
    console.log(`amount: ${outstanding}`);
    console.log(`due: ${invoice.dueDate.toLocaleDateString()}`);
}

function printBanner(){
    console.log("***********************");
    console.log("**** Customer Owes ****");
	console.log("***********************");
}
```

把“打印详细详细”部分提炼出来：

```javascript
function printOwing(invoice){
    let outstanding =0;
    printBanner();
    
    for (const o of invoice.orders) {
        outstanding += o.amount;
    }
    
    const today = Clock.today;
    invoice.dueDate = new Date(today.getFullYear(), today.getMonth(), today.getDate()+30);

 	printDetails();
    // 为了访问源函数的内部变量，把提炼的函数放在了源函数的内部
    function printDetails(){
    	console.log(`name: ${invoice.customer}`);
    	console.log(`amount: ${outstanding}`);
    	console.log(`due: ${invoice.dueDate.toLocaleDateString()}`);
	}
}

function printBanner(){
    console.log("***********************");
    console.log("**** Customer Owes ****");
	console.log("***********************");
}
```

范例二：有局部变量

```javascript
function printOwing(invoice){
    let outstanding = 0;
    printBanner();
    
    for (const o of invoice.orders) {
        outstanding += o.amount;
    }
    
    const today = Clock.today;
    invoice.dueDate = new Date(today.getFullYear(),today.getMonth(),today.getDate()+30);

    console.log(`name: ${invoice.customer}`);
    console.log(`amount: ${outstanding}`);
    console.log(`due: ${invoice.dueDate.toLocaleDateString()}`);
}

function printBanner(){
    console.log("***********************");
    console.log("**** Customer Owes ****");
	console.log("***********************");
}
```

将“打印详细信息”提炼为带两个参数的函数

```javascript
function printOwing(invoice){
    let outstanding =0;
    printBanner();
    
    for (const o of invoice.orders) {
        outstanding += o.amount;
    }
    
    const today = Clock.today;
    invoice.dueDate = new Date(today.getFullYear(), today.getMonth(), today.getDate()+30);

    printDetails(invoice, outstanding);
}

function printDetails(invoice, outstanding) {
    console.log(`name: ${invoice.customer}`);
    console.log(`amount: ${outstanding}`);
    console.log(`due: ${invoice.dueDate.toLocaleDateString()}`);
}

function printBanner(){
    console.log("***********************");
    console.log("**** Customer Owes ****");
	console.log("***********************");
}
```

把“设置到期日”的逻辑也提炼出来：

```javascript
function printOwing(invoice){
    let outstanding =0;
    printBanner();
    
    for (const o of invoice.orders) {
        outstanding += o.amount;
    }
    
    recordDueDate(invoice);
    printDetails(invoice, outstanding);
}

function recordDueDate(invoice){
    const today = Clock.today;
    invoice.dueDate = new Date(today.getFullYear(), today.getMonth(), today.getDate()+30);
}

function printDetails(invoice, outstanding) {
    console.log(`name: ${invoice.customer}`);
    console.log(`amount: ${outstanding}`);
    console.log(`due: ${invoice.dueDate.toLocaleDateString()}`);
}

function printBanner(){
    console.log("***********************");
    console.log("**** Customer Owes ****");
	console.log("***********************");
}
```

范例三：对局部变量再赋值

```javascript
function printOwing(invoice){
    let outstanding =0;
    printBanner();
    
    for (const o of invoice.orders) {
        outstanding += o.amount;
    }
    
    recordDueDate(invoice);
    printDetails(invoice, outstanding);
}
```

首先吧变量的声明移动到使用处之前：

```javascript
function printOwing(invoice){
    printBanner();
    
    let outstanding =0;
    for (const o of invoice.orders) {
        outstanding += o.amount;
    }
    
    recordDueDate(invoice);
    printDetails(invoice, outstanding);
}
```

然后把想要提炼的代码复制到目标函数中

```javascript
function printOwing(invoice){
    printBanner();
    
    let outstanding =0;
    for (const o of invoice.orders) {
        outstanding += o.amount;
    }
    
    recordDueDate(invoice);
    printDetails(invoice, outstanding);
}

function calculateOutstanding(invoice) {
   let outstanding =0;
    for (const o of invoice.orders) {
        outstanding += o.amount;
    }
    return outstanding;
}
```

修改源函数，使其调用新函数

```javascript
function printOwing(invoice){
    printBanner();
    let outstanding = calculateOutstanding(invoice);
    recordDueDate(invoice);
    printDetails(invoice, outstanding);
}

function calculateOutstanding(invoice) {
   let outstanding =0;
    for (const o of invoice.orders) {
        outstanding += o.amount;
    }
    return outstanding;
}
```

修改新函数的返回值名称，保持编码风格一致

```javascript
function printOwing(invoice){
    printBanner();
    c outstanding = calculateOutstanding(invoice);
    recordDueDate(invoice);
    printDetails(invoice, outstanding);
}

function calculateOutstanding(invoice) {
   let result =0;
    for (const o of invoice.orders) {
        result += o.amount;
    }
    return result;
}
```

