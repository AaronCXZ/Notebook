## 12.1 函数上移（Pull Up Method）

1. 名称

2. 一个简单的速写

```javascript
class Employee {...}
class Salesman extends Employee{
    get name(){...}
}
class Engineer extends Employee{
    get name(){...}
}
```

重构为：

```javascript
class Employee {
    get name(){...}
}
class Salesman extends Employee{}
class Engineer extends Employee{}
```

3. 动机

避免重复代码时很重要的。

4. 做法

- 检查待提升函数，确定它们时完全一致的
- 检查函数体内引用的所有函数调用和字段都能从超类中调用到
- 如果待提升函数的签名不同，使用改变函数声明将那些签名都修改为你想要在超类中使用的签名
- 在超类中新建一个函数，将某一个待提升函数的代码复制到其中
- 执行静态检查
- 移除一个待提升的子类函数
- 测试
- 逐一移除待提升的子类函数，直到只剩下超类中的函数为止

5. 范例

```javascript
class Employee extends Party {
    get annualCost(){
        return this.monthlyCost * 12;
    }
}
class Department extends Party {
    get totalAnnualCost(){
        return this.monthlyCost * 12;
    }
}
```

两个函数都引用了monthltCost属性，首先改变函数声明

```javascript
class Employee extends Party {
    get annualCost(){
        return this.monthlyCost * 12;
    }
}
class Department extends Party {
    get annualCost(){
        return this.monthlyCost * 12;
    }
}
```

然后将其中一个子类的函数复制到超类中

```javascript
class Party {
    get annualCost(){
        return this.monthlyCost * 12;
    }    
}
```

## 12.2 字段上移（Pull Up Field）

1. 名称

2. 一个简单的速写

```javascript
class Employee {}
class Salesman extends Employee {
    private String name;
}
class Engineer extends Employee {
    private String name;
}
```

重构为：

```javascript
class Employee {
    protected String name;
}
class Salesman extends Employee {...}
class Engineer extends Employee {...}
```

3. 动机

首先它取出了重复的数据声明；其次它使我可以将使用该字段的行为从子类移至超类，从而去除重复的行为

4. 做法

- 针对待提升之字段，检查它们的所有使用点，确认它们以同样的方式被使用
- 如果这些字段的名称不同，先使用变量改名为它们取个相同的名字
- 在超类中新建一个字段
- 移除子类中的字段
- 测试

5. 范例

## 12.3 构造函数本体上移（Pull Up Constructor Body）

1. 名称

2. 一个简单的速写

  ```javascript
  class Party {...}
  class Employee extends Party {
      constructor(name, id, monthlyCost){
          super();
          this._id = id;
          this._name = name;
          this,_monthlyCost = monthlyCost;
      }
  }
  ```

重构为：

```javascript
class Party {
    constructor(name){
        this._name = name;
    }
}
class Employee extends Party {
    constructor(name, id, monthlyCost){
        super(name);
        this._name = name;
        this,_monthlyCost = monthlyCost;
    }
}
```

3. 动机

4. 做法

- 如果超类还不存在构造函数，首先为其定义一个。确保让子类调用超类的构造函数
- 使用移动语句将子类中构造函数中的公共语句移动到超类的构造函数调用语句之后
- 逐一移除子类间的公共代码，将其提升至超类构造函数中。对于公共代码中引用到的变量，将其作为参数传递给吵了的构造函数
- 测试
- 如果存在无法简单提升至超类的公共代码，先应用提炼函数，再利用函数上移提升之

5. 范例

- 范例一：

```javascript
class Party{}
class Employee extends Party {
    constructor(name, id, monthlyCost){
        super();
        this._id = id;
        this._name = name;
        this,_monthlyCost = monthlyCost;
    }
}
class Department extends Party {
    constructor(name, staff){
        super();
        this._name = name;
        this._staff = staff;
    }
}
```

先用移动语句将Employee中的赋值语句移动到super()调用后面

```javascript
class Employee extends Party {
    constructor(name, id, monthlyCost){
        super();
        this._name = name;
        this._id = id;
        this,_monthlyCost = monthlyCost;
    }
}
```

在超类中使用构造函数，并将name作为参数传递

```javascript
class Party{
    constructor(name){
        this._name = name;
	}
}
class Employee extends Party {
    constructor(name, id, monthlyCost){
        super(name);
        this._id = id;
        this,_monthlyCost = monthlyCost;
    }
}
class Department extends Party {
    constructor(name, staff){
        super(name);
        this._staff = staff;
    }
}
```

- 范例二

```javascript
class Employee {
    constructor(name){...}
    get isPrivileged(){...}
    assignCar(){...}
}
class Manager extends Employee {
    constructor(name, grade){
        super(name);
        this._grade = grade;
        if (this.isPrivileged) this.assignCar();
    }
    get isPrivileged(){
        return this._grade > 4;
    }
}
```

无法简单的将isPrivileged提升至超类，先对公共代码使用提炼函数

```javascript
class Manager extends Employee {
	constructor(name, grade){
        super(name);
        this._grade = grade;
        this.finishConstruction();
    }
    get isPrivileged(){
        return this._grade > 4;
    }
    finishConstruction(){
        if (this.isPrivileged) this.assignCar();
    }
} 
```

然后将提炼得到的函数上移至超类

```javascript
class Employee {
    constructor(name){...}
    get isPrivileged(){...}
    assignCar(){...}
    finishConstruction(){
        if (this.isPrivileged) this.assignCar();
    }
}
```

## 12.4 函数下移（Push Down Method）

1. 名称

2. 一个简单的速写

```javascript
class Employee {
    get quota {...}
}
class Engineer extends Employee {...}
class Salesman extends Employee {...}
```

重构为：

```javascript
class Employee {...}
class Engineer extends Employee {...}
class Salesman extends Employee {
	get quota {...}
}
```

3. 动机

如果超类中的某个函数只与一个或少数几个子类有关，那么最好将其从超类中挪走，放到真正关心它的子类中去。

4. 做法

- 将超类中的函数本体复制到每一个需要此函数的子类中
- 删除超类中的函数
- 测试
- 将该函数从所有不需要它的那些子类中删除
- 测试

5. 范例

## 12.5 字段下移（Push Down Field）

1. 名称

2. 一个简单的速写

```javascript
class Employee {
    private String quota;
}
class Engineer extends Employee {...}
class Salesman extends Emoloyee {...}
```

重构为：

```javascript
class Employee {...}
class Engineer extends Employee {...}
class Salesman extends Employee {
    protected String quota;
}
```

3. 动机

如果某个字段只被一个或少数几个子类用到，就将其搬移到需要该字段的子类中

4. 做法

- 在所有需要该字段的子类中声明该字段
- 将该字段从超类中移除
- 测试
- 将该字段从所有不需要它的那些子类中删掉
- 测试

5. 范例

## 12.6 以子类取代类型码（Replace Type Code with Subclasses）

1. 名称

2. 一个简单的速写

```javascript
function createEmployee(name, type){
    return new Employee(name, type);
}
```

重构为：

```javascript
function createEmployee(name, type){
    switch (type) {
        case "engineer": return new Engineer(name);
        case "salesman": return new Salesman(name):
        case "manager": return new Manager(name);
    }
}
```

3. 动机

应该直接处理携带类型码这个类，还是应该处理类型码本身？？？

4. 做法

- 自封装类型码字段
- 任选一个类型码取值，为其创建一个子类。覆写类型码类的取值函数，令其返回该类型码的字面量值
- 创建一个选择器逻辑，把类型码参数映射到新的子类
- 测试
- 针对每个类型码取值，重复上述“创建子类，添加选择器逻辑”的过程。每次修改后执行测试
- 去除类型码字段
- 测试
- 使用函数下移和以多态取代条件表达式处理原本访问了类型码的函数。全部处理完成之后，就可以移除类型码的访问函数。

5. 范例

- 范例一：

```javascript
class Employee {
    constructor(name, type){
        this.validateType(type);
        this._name = name;
        this._type = type;
    }
    validateType(arg) {
        if (!["engineer", "manager", "salesman"].includes(arg))
            throw new Error(`Employee connot be of type ${arg}`);
    }
    toString(){return `${this._name} (${this._type})`;}
}
```

使用封装变量将类型码自封装起来

```javascript
class Employee {
    constructor(name, type){
        this.validateType(type);
        this._name = name;
        this._type = type;
    }
    validateType(arg) {
        if (!["engineer", "manager", "salesman"].includes(arg))
            throw new Error(`Employee connot be of type ${arg}`);
    }
    get type(){return this._type;}
    toString(){return `${this._name} (${this.type})`;}
}
```

先从"engineer"开始

```javascript
class Engineer extends Employee{
    get type(){return "engineer";}
}
```

先用工厂函数取代构造函数，新建工厂函数

```javascript
function createEmployee(name, type){
    return new Employee(name, type);
}
```

然后把选择器逻辑放入工厂函数

```javascript
function createEmployee(name, type){
    switch(type){
        case "engineer": return new Engineer(name, type);
    }
    return new Employee(name, type);
}
```

处理其余的类型

```javascript
class Salesman extends Employee {
    get type(){return "salesman";}
}
class Manager extends Employee {
    get type(){return "manager";}
}
function createEmployee(name, type){
    switch(type){
        case "engineer": return new Engineer(name, type);
        case "salesman": return new Salesman(name, type):
        case "manager": return new Manager(name, type);
    }
    return new Employee(name, type);
}
```

去掉类型码字段和超类中的取值函数

```javascript
class Employee {
    constructor(name, type){
        this.validateType(type);
        this._name = name;
    }
    validateType(arg) {
        if (!["engineer", "manager", "salesman"].includes(arg))
            throw new Error(`Employee connot be of type ${arg}`);
    }
    toString(){return `${this._name} (${this.type})`;}
}
```

移除验证逻辑

```javascript
class Employee {
    constructor(name, type){
        this._name = name;
    }
    toString(){return `${this._name} (${this.type})`;}
}
function createEmployee(name, type){
    switch(type){
        case "engineer": return new Engineer(name, type);
        case "salesman": return new Salesman(name, type):
        case "manager": return new Manager(name, type);
        default: throw new Error(`Employee connot be of type ${type}`);
    }
}
```

修噶函数声明，去除类型码

```javascript
class Employee {
    constructor(name){
        this._name = name;
    }
    toString(){return `${this._name} (${this.type})`;}
}
function createEmployee(name, type){
    switch(type){
        case "engineer": return new Engineer(name);
        case "salesman": return new Salesman(name):
        case "manager": return new Manager(name);
        default: throw new Error(`Employee connot be of type ${type}`);
    }
}
class Engineer extends Employee{
    get type(){return "engineer";}
}
class Salesman extends Employee {
    get type(){return "salesman";}
}
class Manager extends Employee {
    get type(){return "manager";}
}
```

- 范例二：使用间接继承

```javascript
class Employee {
    constructor(name, type){
        this.validateType(type);
        this._name = name;
        this._type = type;
    }
    validateType(arg) {
        if (!["engineer", "manager", "salesman"].includes(arg))
            throw new Error(`Employee connot be of type ${arg}`);
    }
    get type(){return this._type;}
    set type(arg){this._type = arg;}
    get capitalizedType(){
        return this._type.charAt(0).toUpperCase() + this._type.substr(1).toLowerCase();
    }
    toString(){return `${this._name} (${this.capitalizedType})`;}
}
```

首先以对象取代基本类型包装类型码

```javascript
class EmployeeType {
    constructor(aString){
        this._value = aString;
    }
    toString(){return this._value;}
}
class Employee {
    constructor(name, type){
        this.validateType(type);
        this._name = name;
        this.type = type;
    }
    validateType(arg) {
        if (!["engineer", "manager", "salesman"].includes(arg))
            throw new Error(`Employee connot be of type ${arg}`);
    }
    get typeString(){return this._type.toString();}
    get type(){return this._type;}
    set type(arg){this._type = new EmployeeType(arg);}
    get capitalizedType(){
        return this.typeString.charAt(0).toUpperCase() + this.typeString.substr(1).toLowerCase();
    }
    toString(){return `${this._name} (${this.capitalizedType})`;}
}
```

然后以子类取代类型码

```javascript
class Employee {
    constructor(name, type){
        this.validateType(type);
        this._name = name;
        this.type = type;
    }
    validateType(arg) {
        if (!["engineer", "manager", "salesman"].includes(arg))
            throw new Error(`Employee connot be of type ${arg}`);
    }
    get typeString(){return this._type.toString();}
    get type(){return this._type;}
    set type(arg){this._type = Employee.createEmployeeType(arg);}
    static createEmployeeType(aString){
        switch(aString){
            case "engineer": return new Engineer();
            case "manager": return new Manager();
            case "salesman": return new Salesman();
            default:throw new Error(`Employee connot be of type ${aString}`);
        }
    }
    get capitalizedType(){
        return this.typeString.charAt(0).toUpperCase() + this.typeString.substr(1).toLowerCase();
    }
    toString(){return `${this._name} (${this.type.capitalizedName})`;}
}
class EmployeeType {
     get capitalizedName(){
        return this.toString.charAt(0).toUpperCase() + this.toString.substr(1).toLowerCase();
    }
}
class Engineer extends EmployeeType {
    toString(){return "engineer";}
}
class Manager extends EmployeeType {
    toString(){return "manager";}
}
class Salesman extends EmployeeType {
    toString(){return "salesman";}
}
```

## 12.7 移除子类（Remove Subclass）

1. 名称

2. 一个简单的速写

```javascript
class Person {
    get genderCode(){return "X";}
}
class Male extends Person {
    get genderCode(){return "M";}
}
c;ass Female extends Person {
    get genderCode(){return "F";}
}
```

重构为：

```javascript
class Person {
    get genderCode(){return this._genderCode;}
}
```

3. 动机

4. 做法

- 使用以工厂函数渠道构造函数，把子类的构造函数包装到超类的工厂函数中
- 如果有任何代码检查子类的类型，先用提炼函数把类型检查逻辑包装起来，然后用搬移函数将其搬移到超类。每次修改后执行测试
- 新建一个字段，用于代表子类的类型
- 将原本针对子类的类型做判断的函数改为使用新建的类型字段
- 删除子类
- 测试

5. 范例

```javascript
class Person {
    constructor(name){
        this._name = name;
    }
    get name(){return this._name;}
    get genderCode() {return "X";}
}
class Male extends Person {
    get genderCode(){return "M";}
}
c;ass Female extends Person {
    get genderCode(){return "F";}
}
const numberOfMales = people.filter(p => p instanceof Male).length;
```

先使用提炼函数把“选择哪个类来实例化”的逻辑提炼成工厂函数

```javascript
function createPerson(aRecord){
    let p;
    switch (aRecord.gender){
        case 'M': p = new Male(aRecord.name);break;
        case 'F': p = new Female(aRecord.name);break;
        default: p = new Person(sRecord.name);
    }
    return p;
}
function loadFromInput(data){
    const result = [];
    data.forEach(aRecord => {
        result.push(createPerson(aRecord));
    });
    return result;
}
```

使用内联变量简化工厂函数，使用管道简化loadFromInput函数

```javascript
function createPerson(aRecord){
    switch (aRecord.gender){
        case 'M': return new Male(aRecord.name);
        case 'F': return new Female(aRecord.name);
        default: return new Person(sRecord.name);
    }
}
function loadFromInput(data){
    return data.map(aRecord => createPerson(aRecord));
}
const numberOfMales = people.filter(p => p  isMale(p)).length;
function isMale(aPerson){return aPerson instanceof Male;}
```

然后使用搬移函数将客户端搬移到Person类

```javascript
class Person{
    get isMale() {return this instanceof Male;}
}
const numberOfMales = people.filter(p => p.isMale).length;
```

Person类中添加一个字段来表示子类之间的差异

```javascript
class Person {
    constructor(name, genderCOde){
        this._name = name;
        this._genderCode = genderCode || "X";
    }
    get name(){return this._name;}
    get genderCode() {return this._genderCode;}
    get isMale() {return "M" === this._grandeCode;}
}
```

工厂函数添加对应的参数

```javascript
function createPerson(aRecord){
    switch (aRecord.gender){
        case 'M': return new Male(aRecord.name, 'M');
        case 'F': return new Female(aRecord.name, 'F');
        default: return new Person(sRecord.name, 'X');
    }
}
```

## 12.8 提炼超类（Extract Superclass）

1. 名称

2. 一个简单的速写

```javascript
class Department {
    get totalAnnualCost(){...}
    get name(){...}
    get headCount(){...}
}
class Employee {
   get annualCost(){...}
   get name(){...}
   get id(){...}
}
```

重构为：

```javascript
class Party {
    get name(){...}
    get annualCost(){...}
}
class Department extends Party {
    get annualCost(){...}
    get headCount(){...}
}
class Employee extends Party {
    get annualCost(){...}
    get id(){...}
}
```

3. 动机

如果两个类在做相似的事，可以利用基本的继承机制把它们的相似指出提炼到超类

4. 做法

- 为原本的类新建一个空白的超类
- 测试
- 使用构造函数本体上移、函数上移和字段上移手法，逐一将子类的共同元素上移到超类
- 检查留在子类中的函数，看它们是否还有共同的成分。如果有，可以先用提炼函数将其提炼出来，再用函数上移搬到超类
- 检查所有使用原本的类的客户端代码，考虑将其调整为使用超类的接口

5. 范例

```javascript
class Empliyee {
    constructor(name, id, monthlyCost){
        this._id = id;
        this._name = name;
        this._monthlyCost = monthlyCost;
    }
    get monthlyCost(){return this._monthlyCost;}
    get name(){return this._name;}
    get id(){return this._id;}
    get annualCost(){return this.monthlyCost * 12;}
}
class Department {
    constructor(name, staff){
        this._name = name;
        this._staff = staff;
    }
    get staff(){return this._staff;}
    get name(){return this._name;}
    get totalMonthlyCost(){
        return this.staff
            .map(e => e.monthlyCost)
            .reduce((sum, cost) => sum + cost);
    }
    get headCount(){return this.staff.length;}
    get totalAnnualCost(){return this.totalMonthlyCost * 12;}
}
```

首先创建一个空的超类，让原来的两个类都继承这个新的类

```javascript
class Party {}
class Empliyee extends Party {
    constructor(name, id, monthlyCost){
        super();
        this._id = id;
        this._name = name;
        this._monthlyCost = monthlyCost;
    }
    get monthlyCost(){return this._monthlyCost;}
    get name(){return this._name;}
    get id(){return this._id;}
    get annualCost(){return this.monthlyCost * 12;}
}
class Department extends Party {
    constructor(name, staff){
        super();
        this._name = name;
        this._staff = staff;
    }
    get staff(){return this._staff;}
    get name(){return this._name;}
    get totalMonthlyCost(){
        return this.staff
            .map(e => e.monthlyCost)
            .reduce((sum, cost) => sum + cost);
    }
    get headCount(){return this.staff.length;}
    get totalAnnualCost(){return this.totalMonthlyCost * 12;}
}
```

用上移字段把name搬到超类中

```javascript
class Party {
    constructor(name){
        this._name = name;
    }
}
class Empliyee extends Party {
    constructor(name, id, monthlyCost){
        super(name);
        this._id = id;
        this._monthlyCost = monthlyCost;
    }
    get monthlyCost(){return this._monthlyCost;}
    get name(){return this._name;}
    get id(){return this._id;}
    get annualCost(){return this.monthlyCost * 12;}
}
class Department extends Party {
    constructor(name, staff){
        super(name);
        this._staff = staff;
    }
    get staff(){return this._staff;}
    get name(){return this._name;}
    get totalMonthlyCost(){
        return this.staff
            .map(e => e.monthlyCost)
            .reduce((sum, cost) => sum + cost);
    }
    get headCount(){return this.staff.length;}
    get totalAnnualCost(){return this.totalMonthlyCost * 12;}
}
```

用函数上移把相关的函数也搬移到超类

```javascript
class Party {
    constructor(name){
        this._name = name;
    }
    get name(){return this._name;}
}
class Empliyee extends Party {
    constructor(name, id, monthlyCost){
        super(name);
        this._id = id;
        this._monthlyCost = monthlyCost;
    }
    get monthlyCost(){return this._monthlyCost;}
    get name(){return this._name;}
    get id(){return this._id;}
    get annualCost(){return this.monthlyCost * 12;}
}
class Department extends Party {
    constructor(name, staff){
        super(name);
        this._staff = staff;
    }
    get staff(){return this._staff;}
    get name(){return this._name;}
    get totalMonthlyCost(){
        return this.staff
            .map(e => e.monthlyCost)
            .reduce((sum, cost) => sum + cost);
    }
    get headCount(){return this.staff.length;}
    get totalAnnualCost(){return this.totalMonthlyCost * 12;}
}
```

把两个函数体相似的函数进行改变函数声明

```javascript
class Party {
    constructor(name){
        this._name = name;
    }
    get name(){return this._name;}
}
class Empliyee extends Party {
    constructor(name, id, monthlyCost){
        super(name);
        this._id = id;
        this._monthlyCost = monthlyCost;
    }
    get monthlyCost(){return this._monthlyCost;}
    get name(){return this._name;}
    get id(){return this._id;}
    get annualCost(){return this.monthlyCost * 12;}
}
class Department extends Party {
    constructor(name, staff){
        super(name);
        this._staff = staff;
    }
    get staff(){return this._staff;}
    get name(){return this._name;}
    get monthlyCost(){
        return this.staff
            .map(e => e.monthlyCost)
            .reduce((sum, cost) => sum + cost);
    }
    get headCount(){return this.staff.length;}
    get annualCost(){return this.monthlyCost * 12;}
}
```

然后将函数搬移到超类中

```javascript
class Party {
    constructor(name){
        this._name = name;
    }
    get name(){return this._name;}
	get annualCost(){return this.monthlyCost * 12;}
}
class Empliyee extends Party {
    constructor(name, id, monthlyCost){
        super(name);
        this._id = id;
        this._monthlyCost = monthlyCost;
    }
    get monthlyCost(){return this._monthlyCost;}
    get id(){return this._id;}
}
class Department extends Party {
    constructor(name, staff){
        super(name);
        this._staff = staff;
    }
    get staff(){return this._staff;}
    get monthlyCost(){
        return this.staff
            .map(e => e.monthlyCost)
            .reduce((sum, cost) => sum + cost);
    }
    get headCount(){return this.staff.length;}
}
```

## 12.9 折叠继承关系（Collapse Hierarchy）

1. 名称

2. 一个简单的速写

```javascript
class Employee {...}
class Salesman extends Employee {...}
```

重构为：

```javascript
class Employee {...}
```

3. 动机

有时会发现一个类与其超类已经没有多大的差别了，不值得再作为独立的类存在，可以把超类和子类合并起来

4. 做法

- 选择香移除的类：是超类还是子类？
- 使用字段上移、字段下移、函数上移和函数下移，把所有元素都移到同一个类中
- 调整即将被移除的那个类的所有引用点，令它们改而引用合并后留下的类
- 移除我们的目标，此时它应该已经是一个空类
- 测试

5. 范例

## 12.10 以委托取代子类（Replace Subclass with Delegate）

1. 名称

2. 一个简单的速写

```javascript
class Orde {
    get daysToShip(){
        return this._warehouse.daysToShip;
    }
}
class PriorityOrder extends Order {
    get daysToShip(){
        return this.priorityPlan.daysToShip;
    }
}
```

重构为：

```javascript
class Order {
    get daysToShip(){
        return (this._priorityDelegate)
        	? this._priorityDelegate.daysToShip
        	: this._warehouse.daysToShip;
    }
}
class PriorityOrderDelegate {
    get daysToShip(){
        return this._priorityPlan.daysToShip;
    }
}
```

3. 动机

导致行为不同的原因可能有多种，但是继承只能用于处理一个方向上的变化

4. 做法

- 如果构造函数有多个调用者，首先用以工厂函数取代构造函数把构造函数包装起来
- 创建一个空的委托类，这个类的构造函数应该接受所有子类特有的数据项，并且经常以参数的形式接受一个指回超类的引用
- 在超类中添加一个字段，用于安放委托对象
- 修改子类的创建逻辑，使其初始化上述委托字段，放入一个委托对象的实例
- 选择一个子类中的函数，将其移入委托类
- 使用搬移函数手法搬移上述函数，不要删除源类中的委托代码
- 如果被搬移的源函数还在自了之外被调用了，就把留在源类中的委托代码从子类移到超类，并再委托代码之前加上卫语句，检查委托对象存在。如果子类之外已经没有其他调用者，就用移除死代码去掉已经没人使用的委托代码
- 测试
- 重复上述过程，直到子类中所有函数都搬到委托类
- 找到所有调用子类构造函数的地方，逐一将其改为使用超类的构造函数
- 测试
- 运用移除死代码去掉子类

5. 范例

- 范例一：

```javascript
class Booking {
    constructor(show, date){
        this._show = show;
        this._date = date;
    }
    get hasTalkback(){
        return this._show.hasOwnProperty('talkback') && !this.isPeakDay;
    }
    get basePrice(){
        let result = this._show.price;
        if (this.isPeakDay) result += Math.round(result * 0.15);
        return result;
    }
}
class PremiumBooking extend Booking {
    constructor(show, date, extras){
        super(show, date);
        this._extras = extras;
    }
    get hasTalkback(){
        return this._show.hasOwnProperty('talkback');
    }
    get basePrice(){
        return Math.round(super.basePrice + this._extras.premiumFee);
    }
    get hasDinner(){
        return this._extras.hasOwnProperty('dinner') && !this.isPeakDay;
    }
}
// 客户端1
aBooking = new Booking(show, date);
// 客户端2
aBooking = new PremiumBooking(show, date, extras);
```

先用工厂函数取代构造函数

```javascript
function createBooking(show, date){
    return new Booking(show, date);
}
function createPremiumBooking(show, date, extras){
    return new PremiumBooking(show, date, extras); 
}
// 客户端1
aBooking = createBooking(show, date);
// 客户端2
aBooking = createPremiumBooking(show, date, extras);
```

然后新建一个委托类

```javascript
class PremiumBookingDelegate {
    constructor(hostBooking, extras){
        this._host - hostBooking;
        this._extras = extras;
    }
}
```

就新建的委托类对象与Booking对象关联起来

```javascript
function createPremiumBooking(show, date, extras){
    const result = new PremiumBooking(show, date, extras); 
    result._bePremium(extras);
    return result
}
class Booking {
    constructor(show, date){
        this._show = show;
        this._date = date;
    }
    get hasTalkback(){
        return this._show.hasOwnProperty('talkback') && !this.isPeakDay;
    }
    get basePrice(){
        let result = this._show.price;
        if (this.isPeakDay) result += Math.round(result * 0.15);
        return result;
    }
    _bePremium(extras){
        this._premiumDelegate = new PremiumBookingDelegate(this, extras);
    }
}
```

使用搬移函数把子类中的函数搬到委托类中

```javascript
class PremiumBookingDelegate {
    constructor(hostBooking, extras){
        this._host - hostBooking;
        this._extras = extras;
    }
    get hasTalkback(){
        return this._host._show.hasOwnProperty('talkback');
    }
}
class Booking {
    constructor(show, date){
        this._show = show;
        this._date = date;
    }
    get hasTalkback(){
        return (this._premiumDelegate)
        	? this._premiumDelegate.hasTalkback
        	: thsi._show.hasOwnProperty('talkback') && !this.isPeakDay;
    }
    get basePrice(){
        let result = this._show.price;
        if (this.isPeakDay) result += Math.round(result * 0.15);
        return result;
    }
    _bePremium(extras){
        this._premiumDelegate = new PremiumBookingDelegate(this, extras);
    }
}
class PremiumBooking extend Booking {
    constructor(show, date, extras){
        super(show, date);
        this._extras = extras;
    }
    get basePrice(){
        return Math.round(super.basePrice + this._extras.premiumFee);
    }
    get hasDinner(){
        return this._extras.hasOwnProperty('dinner') && !this.isPeakDay;
    }
}
```

下面处理basePrice函数

```javascript
class PremiumBookingDelegate {
    constructor(hostBooking, extras){
        this._host - hostBooking;
        this._extras = extras;
    }
    get hasTalkback(){
        return this._host._show.hasOwnProperty('talkback');
    }
    extendBasePrice(base){
        return Math.round(base + this._extras.premiumFee);
    }
}
class Booking {
    constructor(show, date){
        this._show = show;
        this._date = date;
    }
    get hasTalkback(){
        return (this._premiumDelegate)
        	? this._premiumDelegate.hasTalkback
        	: thsi._show.hasOwnProperty('talkback') && !this.isPeakDay;
    }
    get basePrice(){
        let result = this._show.price;
        if (this.isPeakDay) result += Math.round(result * 0.15);
        return (this._permiumDelegate)
        	? this._premiumDelegate.extendBasePrice(result)
        	: result;
    }
    _bePremium(extras){
        this._premiumDelegate = new PremiumBookingDelegate(this, extras);
    }
}
class PremiumBooking extend Booking {
    constructor(show, date, extras){
        super(show, date);
        this._extras = extras;
    }
    get basePrice(){
        return Math.round(super.basePrice + this._extras.premiumFee);
    }
    get hasDinner(){
        return this._extras.hasOwnProperty('dinner') && !this.isPeakDay;
    }
}
```

最后把只存在一个子类中的函数hasDinner从子类移到委托类

```javascript
class PremiumBookingDelegate {
    constructor(hostBooking, extras){
        this._host - hostBooking;
        this._extras = extras;
    }
    get hasTalkback(){
        return this._host._show.hasOwnProperty('talkback');
    }
    extendBasePrice(base){
        return Math.round(base + this._extras.premiumFee);
    }
    get hasDinner(){
        return (this._premiumDelegate)
        	? this._premiumDelegate.hasDinner
        	: undefined;
    }
}
```

删除子类

```javascript
class PremiumBookingDelegate {
    constructor(hostBooking, extras){
        this._host - hostBooking;
        this._extras = extras;
    }
    get hasTalkback(){
        return this._host._show.hasOwnProperty('talkback');
    }
    extendBasePrice(base){
        return Math.round(base + this._extras.premiumFee);
    }
    get hasDinner(){
        return (this._premiumDelegate)
        	? this._premiumDelegate.hasDinner
        	: undefined;
    }
}
class Booking {
    constructor(show, date){
        this._show = show;
        this._date = date;
    }
    get hasTalkback(){
        return (this._premiumDelegate)
        	? this._premiumDelegate.hasTalkback
        	: thsi._show.hasOwnProperty('talkback') && !this.isPeakDay;
    }
    get basePrice(){
        let result = this._show.price;
        if (this.isPeakDay) result += Math.round(result * 0.15);
        return (this._permiumDelegate)
        	? this._premiumDelegate.extendBasePrice(result)
        	: result;
    }
    _bePremium(extras){
        this._premiumDelegate = new PremiumBookingDelegate(this, extras);
    }
}
function createBooking(show, date){
    return new Booking(show, date);
}
function createPremiumBooking(show, date, extras){
    const result = new Booking(show, date);
    result._bePremium(extras);
    return result;
}
// 客户端1
aBooking = createBooking(show, date);
// 客户端2
aBooking = createPremiumBooking(show, date, extras);
```

- 范例二：取代继承体系

```javascript
function createBird(data){
    switch(data.type){
        case 'EuropeanSwallow':
            return new EuropeanSwallow(data);
        case 'AfricanSwallow':
            return new AfricanSwallow(data);
        case 'NorweigianBlueParrot':
            return new NorweigianBlueParrot(data);
        default:
            return new Bird(data);
    }
}
class Bird {
    constructor(data){
        this._name  data.name;
        this._plumage = data.plumage;
    }
    get name(){return this._name;}
    get plumage(){return this._plimage || "average";}
    get airSpeedVelocity(){return null;}
}
class EuropeanSwallow extends Bird {
    get airSpeedVelocity(){return 35;} 
}
class AfricanSwallow extends Bird {
    constructor(data){
        super(data);
        this._numberOfCoconuts = data.numberOfCoconuts;
    }
    get airSpeedVelocity(){return 40 - 2 * this._numberOfCoconuts;}
}
class NorweigianBlueParrot extends Bird {
    constructor(data){
        super(data);
        this._voltage = data.vpltage;
        this._isNailed = data.isNailed;
    }
    get plumage(){
        if (this._voltage > 100) return "scorched";
        else return this._plumage || "beautiful";
    }
    get airSpeedVelocity(){
        return (this._isNailed) > 0 : 10 + this._voltage / 10;}
}
```

先给EuropeanSwallow创建一个空的委托类

```javascript
class EuropeanSwallowDelegate {}
```

再Bird类新建一个函数，根据类型码选择适当的委托对象

```javascript
class Bird {
    constructor(data){
        this._name  data.name;
        this._plumage = data.plumage;
        this._speciesDelegate = this.selectSpeciesDelegate(data);
    }
    get name(){return this._name;}
    get plumage(){return this._plimage || "average";}
    get airSpeedVelocity(){return null;}
    selectSpeciesDelegate(data){
        switch (data.type){
            case 'EuropeanSwallow':
                return new EuropeanSwallowDelegate();
            default: return null;
        }
    }
}
```

把airSpeedVelocity函数搬移到委托对象中

```javascript
class EuropeanSwallowDelegate {
        get airSpeedVelocity(){return 35;} 
}
class EuropeanSwallow extends Bird {
    get airSpeedVelocity(){
        return this._speciesDelegate.airSpeedVelocity;
    } 
}
```

修改超类的airSpeedVelocity函数

```javascript
class Bird {
    constructor(data){
        this._name  data.name;
        this._plumage = data.plumage;
    }
    get name(){return this._name;}
    get plumage(){return this._plimage || "average";}
    get airSpeedVelocity(){
        return this._speciesDelegate ? this._speciesDelegate.airSpeedVelocity : null;
    }
    selectSpeciesDelegate(data){
        switch (data.type){
            case 'EuropeanSwallow':
                return new EuropeanSwallowDelegate();
            default: return null;
        }
    }
}
```

然后删除子类EuropeanSwallow

```javascript
function createBird(data){
    switch(data.type){
        case 'AfricanSwallow':
            return new AfricanSwallow(data);
        case 'NorweigianBlueParrot':
            return new NorweigianBlueParrot(data);
        default:
            return new Bird(data);
    }
}
```

接下来处理AfricanSwallow子类，先创建委托类

```javascript
class AfricanSwallowDelegate {
    constructor(data){
	this._numberOfCoconuts = data.numberOfCoconuts;    }
}
class Bird {
    constructor(data){
        this._name  data.name;
        this._plumage = data.plumage;
    }
    get name(){return this._name;}
    get plumage(){return this._plimage || "average";}
    get airSpeedVelocity(){
        return this._speciesDelegate ? this._speciesDelegate.airSpeedVelocity : null;
    }
    selectSpeciesDelegate(data){
        switch (data.type){
            case 'EuropeanSwallow':
                return new EuropeanSwallowDelegate();
            case 'AfricanSwallow':
            	return new AfricanSwallowDelegate(data);
            default: return null;
        }
    }
}
```

同样把airSpeedVelocity函数搬移到委托类

```javascript
class AfricanSwallowDelegate {
    constructor(data){
		this._numberOfCoconuts = data.numberOfCoconuts;
    }
	get airSpeedVelocity(){return 40 - 2 * this._numberOfCoconuts;}
}
class AfricanSwallow extends Bird {
    get airSpeedVelocity(){return this._speciesDelegate.airSpeedVelocity;}
}
```

然后删除AfricanSwallow子类

```javascript
function createBird(data){
    switch(data.type){
        case 'NorweigianBlueParrot':
            return new NorweigianBlueParrot(data);
        default:
            return new Bird(data);
    }
}
```

接下来处理NorweigianBlueParrot子类，最终结果

```javascript
class Bird {
    constructor(data){
        this._name  data.name;
        this._plumage = data.plumage;
    }
    get name(){return this._name;}
    get plumage(){return this._plimage || "average";}
    get airSpeedVelocity(){
        return this._speciesDelegate ? this._speciesDelegate.airSpeedVelocity : null;
    }
    selectSpeciesDelegate(data){
        switch (data.type){
            case 'EuropeanSwallow':
                return new EuropeanSwallowDelegate();
            case 'AfricanSwallow':
            	return new AfricanSwallowDelegate(data);
            case 'NorweigianBlueParrot':
            	return new NorweigianBlueParrotDelegate(data);
            default: return null;
        }
    }
}
class NorweigianBlueParrotDelegate {
    constructor(data){
        this._voltage = data.vpltage;
        this._isNailed = data.isNailed;
    }
    get airSpeedVelocity(){
        return (this._isNailed) > 0 : 10 + this._voltage / 10;
    }
}
```

然后将plumage函数搬移到委托类中

```javascript
class NorweigianBlueParrotDelegate {
    constructor(data, bird){
        this._bird = bird;        
        this._voltage = data.vpltage;
        this._isNailed = data.isNailed;
    }
    get plumage(){
        if (this._voltage > 100) return "scorched";
        else return this._plumage || "beautiful";
    }
    get airSpeedVelocity(){
        return (this._isNailed) > 0 : 10 + this._voltage / 10;
    }
}
class NorweigianBlueParrot extends Bird {
    constructor(data){
        this._voltage = data.vpltage;
        this._isNailed = data.isNailed;
    }
    get plumage(){
        this.__speciesDelegate.plumage;
    }
    get airSpeedVelocity(){
        return this.__speciesDelegate.airSpeedVelocity;
    }
}
class Bird {
    constructor(data){
        this._name  data.name;
        this._plumage = data.plumage;
    }
    get name(){return this._name;}
    get plumage(){return this._plimage || "average";}
    get airSpeedVelocity(){
        return this._speciesDelegate ? this._speciesDelegate.airSpeedVelocity : null;
    }
    selectSpeciesDelegate(data){
        switch (data.type){
            case 'EuropeanSwallow':
                return new EuropeanSwallowDelegate();
            case 'AfricanSwallow':
            	return new AfricanSwallowDelegate(data);
            case 'NorweigianBlueParrot':
            	return new NorweigianBlueParrotDelegate(data, this);
            default: return null;
        }
    }
}
```

去除子类的plumage函数，使用提炼超级类

```javascript
class SpeciesDelegate {
    constructor(data, bird){
        this._bird = bird;
    }
    get plumage(){
        return this._bird._plumage || "average";
    }
}
class EuropeanSwallowDelegate extends SpeciesDelegate {}
class AfricanSwallowDelegate extends SpeciesDelegate {
    constryctor(data, bird){
        spuer(data, bird);
        this._numberOfCounts = data.numberOfCounts;
    }
}
class NorweigianBlueParrotDelegate extends SpeciesDelegate{
    constructor(data, bird){
        super(data, bird);
        this._voltage = data.voltage;
        this._isNailed = data.isNailed;
    }
}
```

有了共同的超级类之后可以把一些字段和函数搬移到超级类中，最终结果如下：

```javascript
function createBird(data){
    return new Bird(data);
}
class Bird {
    constructor(data){
        this._name  data.name;
        this._plumage = data.plumage;
        this._speciesDelegate = this.selectSpeciesDelegate(data);        
    }
    get name(){return this._name;}
    get plumage(){return this._speciesDelegate.plumage;}
    get airSpeedVelocity(){return this._speciesDelegate.airSpeedVelocity;}
    selectSpeciesDelegate(data){
        switch (data.type){
            case 'EuropeanSwallow':
                return new EuropeanSwallowDelegate(data, this);
            case 'AfricanSwallow':
            	return new AfricanSwallowDelegate(data, this);
            case 'NorweigianBlueParrot':
            	return new NorweigianBlueParrotDelegate(data, this);
            default: return new SpeciesDelegate(data, this);
        }
    }
}
class SpeciesDelegate {
    constructor(data, bird){
        this._bird = bird;
    }
    get plumage(){
        return this._bird._plumage || "average";
    }
    get airSpeedVelocity(){return nul;}
}
class EuropeanSwallowDelegate extends SpeciesDelegate {
   get airSpeedVelocity(){return 35;} 
}
class AfricanSwallowDelegate extends SpeciesDelegate {
    constryctor(data, bird){
        spuer(data, bird);
        this._numberOfCounts = data.numberOfCounts;
    }
    get airSpeedVelocity(){
        return 40 - 2 * this._numberOfCounts;
    } 
}
class NorweigianBlueParrotDelegate extends SpeciesDelegate{
    constructor(data, bird){
        super(data, bird);
        this._voltage = data.voltage;
        this._isNailed = data.isNailed;
    }
    get airSpeedVelocity(){
        return (this._isNailed) > 0 : 10 + this._voltage / 10; 
    }
    get plumage(){
        if (this._voltage > 100) return "scorched";
        else return this._bird._plumage || "beautifull";
    }
}
```































































