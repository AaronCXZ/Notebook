### X86通用寄存器

#### 32位架构

有8个32位的寄存器，在汇编语言中可以通过名称直接引用这8个寄存器

| 编号 | 名称 | 用途                                                         |
| :--: | :--: | :----------------------------------------------------------- |
|  0   | EAX  | 会被乘法和除法指令自动使用，通常称为扩展累加寄存器           |
|  1   | ECX  | 被LOOP系列指令用作循环计数器                                 |
|  2   | EDX  |                                                              |
|  3   | EBX  |                                                              |
|  4   | ESP  | 用来寻址栈上的数据，很少用于普通算数和数据传输，通常称为扩展栈指针寄存器 |
|  5   | EBP  | 用来引用栈上的函数参数和局部变量，称为扩展帧指针寄存器       |
|  6   | ESI  | 被高速内存传输指令用来只想源地址，被称为扩展源索引寄存器     |
|  7   | EDI  | 被高速内存传输指令用来只想目的地址，被称为扩展源目的引寄存器 |

编号0～3的4个寄存器还可以进一步拆分，例如EAX的低16位可以单独使用，引用名称为AX，而AX又可以进一步拆分成高字节的AH和低字节的AL两个8位寄存器，拆分方式如下

| 32位 | 16位 | 高8位 | 低8位 |
| :--: | :--: | :---: | :---: |
| EAX  |  AX  |  AH   |  AL   |
| ECX  |  CX  |  CH   |  CL   |
| EDX  |  DX  |  DH   |  DL   |
| ESX  |  SX  |  BH   |  BL   |

编号4～7的4歌寄存器，低16位也有独立的名称，但是没有对应的8位寄存器，具体如下：

| 32位 | 16位 |
| :--: | :--: |
| ESP  |  SP  |
| EBP  |  BP  |
| ESI  |  SI  |
| EDI  |  DI  |

特殊的寄存器：

- EIP：指令指针寄存器，存储的是下一条将要被执行的指令的地址。汇编语言中不能通过名称直接使用EIP，只能通过跳转/CALL和RET等指令间接修改EIP的值。

#### 64位架构

16个64位的寄存器，每个寄存器的低8位，16位，32位都可以单独使用

|  64位  |   32位   |   16位   |   8位    |
| :----: | :------: | :------: | :------: |
|  RAX   |   EAX    |    AX    |    AL    |
|  RCX   |   ECX    |    CX    |    CL    |
|  RDX   |   EDX    |    DX    |    DL    |
|  RBX   |   EBX    |    BX    |    BL    |
|  RSP   |   ESP    |    SP    |   SPL    |
|  RBP   |   EBP    |    BP    |   BPL    |
|  RSI   |   ESI    |    SI    |   SIL    |
|  RDI   |   EDI    |    DI    |   DIL    |
| R8~R15 | R8D~R15D | R8W~R15W | R8B~R15B |

- 指令指针EIP被扩展为64位，但依然不能在代码中直接引用
- 标志寄存器EFLAGS被控制为64位的RFIAGS，里面的标志位保持向前兼容

### 常用汇编指令

#### 整数加减指令

使用ADD指令进行整数的加法运算，该指令有两个操作数，第一个操作数也叫目的操作数，第二个操作数也叫做源操作数。ADD指令将两个操作数的值相加，然后把结果放到目的操作数中。源操作数可以是寄存器，内存，立即数。而目的操作数需要满足可写的条件，所以只能是寄存器或内存，而且两个操作数不能用时为内存。

例如：`ADD   EAX,   16` 的意思是EAX寄存器加16之后的数写入EAX寄存器

使用SUB指令进行整数的减法运算，对操作数的要求和ADD指令一致

例如：`SUB  ESP,   32` 的意思是ESP寄存器减32之后的数写入ESP寄存器

#### 数据传输指令

MOV指令主要用来在寄存器之间以及寄存器和内存之间传输数据，也可以用来把一个立即数下入到寄存器或内存中

第一个操作数称为目的操作数，第二个操作数称为源操作数，MOV指令把源操作数的值复制到目的操作数中

例如： `MOV    EAX,    ECX`  把ECX寄存器的值复制到EAX寄存器中

例如： `MOV      EDX,     1234`  把数值1234复制到EDX寄存器中

几种内存寻址方式：指令可以直接给出内存地址的偏移量，又称为位移，也可以通过一项或多项数据计算得到一个地址

1. Displacement：位移，是一个8位，16位或32位的值
2. Base：基址，存放在某个通用寄存器中
3. Index：索引，存放在某个通用寄存器中，ESP不可用作索引
4. Scale：比例因子，用来于索引相乘，计算公式如下：Effective Address = Base + （Index * Scale）+ Displacement

1. 位移：表示距离操作数的直接偏移量，一般用于贬义阶段静态分配的全局变量之类
2. 基址：将内存地址存储在某个通用寄存器中，寄存器的值可以变化，一般用于运行时动态分配的变量，数据结构等
3. 基址+位移：基址加位移，尤其适合寻址运行时动态分配的数据结构的字段，以及函数栈帧上的变量

```汇编
MOV EAX, [16]				# 位移16位的数据复制到EAX寄存器
MOV EAX, [ESP]			# 基址位于ESP寄存器中的数据复制到EAX寄存器
MOV EAX, [ESP + 16]		# 基址位于ESP寄存器中再位移16位的数据复制到EAX寄存器
```

#### 入栈和出栈指令

入栈指令PUSH只有一个操作数，即要入栈的源操作数，PUSH会先将ESP向下移动一个位置，然后把源操作数复制到ESP指向的内存处，例如`PUSH EAX`等价于：

```
SUB ESP, 4				#向下移动一个位置
MOV [ESP], EAX		# 将EAX寄存器中的数据复制到ESP寄存器的位置，把ESP用作基址进行寻址
```

出栈指令POP也只有一个操作数，是用来接收数据的目的操作数。POP指令会先把ESP指向的内存处的值复制到目的操作数中，然后把ESP向上移动一个位置，例如： `POP  EAX` 等价于：

```
MOV EAX, [ESP]
ADD ESP, 4
```

#### 分支跳转指令

无条件跳转指令JMP只有一个操作数，可以是一个立即数，通用寄存器或内存位置，通过这个操作数给出了将要跳转到的目的地址。例如

```
JMP 32						# 跳转到32处
JMP EAX						# 跳转目的地址经由EAX给出
JMP [EAX + 32]		# 跳转目的地址经由内存位置给出
```

#### 过程调用指令

过程通过调用CALL指令实现，该指令和跳转指令一样只有一个操作数，也就是过程的起始地址。可以认为CALL再JMP的基础上多了一步记录返回地址的操作，返回地址就是紧随CALL之后的下一条指令的地址。CALL指令先把返回地址入栈，然后跳转到目的地址执行。目的地址也可以经由一个立即数，通用寄存器或内存给出，假如下一条指令的地址为32，代码如下

```
CALL EAX
```

等价于：

```
PUSH 32
JMP EAX
```

子过程执行完成后通过RET指令返回，RET指令会从栈上弹出返回地址，并跳转到该地址处继续执行

RET指令有两种格式，

- 一种没有操作数，只用来完成返回地址弹出和跳转
- 另一种有一个立即数参数，在上层语言实现某些调用约定时用来调整栈指针

```
RET 8
```

等价于：

```
RET
ADD ESP, 8
```

### 内存分页机制

#### 线性地址

在分页模式下，应用程序中使用的地址被称为线性地址，需要MMU（Memory Management Unit）基于页表映射转换为物理地址，整个转换过程对于应用程序时完全透明的。

#### 80386两级页表

80386架构的线性地址的宽度为32位，所以可以寻址4GB大小的内存，与进程的地址空间大小相对应。

地址总线为32位，硬件可以寻址4GB的物理内存。分页机制将每个物理内存页面的大小设定位4096字节，并按照4096对齐。所以每个页面中正好可以存储1024个物理页面的地址。

完整的页表结构的第一层是一个页目录页面，其物理地址存储在CR3寄存器中，通过页目录进一步找到第二层的1024个页表页面。

32位的线性地址被MMU按照10位+10位+12位划分，

前两个10位的取值范围都是0～1023，分别用作页目录和页表索引。最后的123位取值范围为0～4096，用作最终对策页面内偏移。

#### PAE三级页表

物理地址扩展技术（Physical Address Extension）PAE：将地址总线扩展到36位，从而使硬件能够寻址多达64GB的物理内存。

线性地址的宽度仍然为32位，MMU的页表映射机制需要相应的调整，以支持从32位线性地址到36位物理地址的映射。

页目录和页表中的地址项被调整为64位，一个页面只能存512个地址。

MMU将32位的线性地址按照2位+9位+9位+12位划分，在页目录之前又增加了一层页目录指针，总共三级页表映射。

高两位用来选择一个页目录，接下来的9位用来选择一个页面，再用9位来选择一个物理页面，再加上最后的12位的偏移值，最终确定一个物理地址

#### x64四级页表

在amd64上，寄存器的宽度变成了64位，而学校地址实际只用到48位，也就是最大可寻址256TB的内存

amd64在PAE的基础上进一步把页表扩展为四级，每个页面的大小仍然是4096字节，MMU将48位的学校地址按照9位+9位+9位+9位+12位划分。

高9位选择也个页目录指针表，再用9位选择一个叶目录，再9位选择页表，再9位选择物理页面，最后12位依然用作页内偏移值

#### 虚拟内存

进程是以页面位单位向操作系统申请内存的，操作系统一般只是对进程已申请的区间进行记账，并不会立即映射所有页面。等到进程真正去访问某个未映射的页面时，才会触发Page Fault异常，操作系统注册的Page Fault Handler会检查记账：

- 如果目的地址已申请，就是合法访问，系统会分配一个物理页面并完成映射，饭后恢复被中断的程序，程序对这一切都是无感的
- 如果买不地址维申请，就是非法访问，系统一般会通过信号，异常等机制结束目标进程

当物理内存不够用时，操作系统可以把一些不常使用的物理页面写到磁盘交换分区或交换文件，从而能够将空出的页面给需要的进程使用

当被交换到磁盘的页面再次被访问时，也会触发Page Fault，由Page Fault Handler负责从交换分区把数据加载回内存

### 汇编代码风格

Go语言使用的汇编代码的风格是基于Plan9汇编器的风格做了一些调整

#### 操作数宽度

Go汇编通过指令的后缀来判断操作数的宽度，后缀W代表16位，后缀L代表32位，后缀Q代表64位

#### 操作数顺序

Go汇编中的操作数顺序是反的，源操作数在前面，而目的操作数在后面

#### 地址的表示

有效地址的计算公式：Effective Address = Base + （Index * Scale）+ Displacement

如果要用ESP作为基址寄存器，EBX作为索引寄存器，比例系数位2，位移为16，则写作：

Intel汇编代码：

```
[ESP + EBX * 2 + 16]
```

Go汇编代码如下：

```
16(SP)(BX*2)
```

#### 立即数格式

Go汇编中的立即数需要加上$前缀

Intel汇编代码：

```
MOV ESX, 1234
```

Go汇编代码：

```
MOVL $ 1234, AX
```

