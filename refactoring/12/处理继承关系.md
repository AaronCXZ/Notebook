## 12.1 函数上移（Pull Up Method）

1. 名称

2. 一个简单的速写

```javascript
class Employee {...}
class Salesman extends Employee{
    get name(){...}
}
class Engineer extends Employee{
    get name(){...}
}
```

重构为：

```javascript
class Employee {
    get name(){...}
}
class Salesman extends Employee{}
class Engineer extends Employee{}
```

3. 动机

避免重复代码时很重要的。

4. 做法

- 检查待提升函数，确定它们时完全一致的
- 检查函数体内引用的所有函数调用和字段都能从超类中调用到
- 如果待提升函数的签名不同，使用改变函数声明将那些签名都修改为你想要在超类中使用的签名
- 在超类中新建一个函数，将某一个待提升函数的代码复制到其中
- 执行静态检查
- 移除一个待提升的子类函数
- 测试
- 逐一移除待提升的子类函数，直到只剩下超类中的函数为止

5. 范例

```javascript
class Employee extends Party {
    get annualCost(){
        return this.monthlyCost * 12;
    }
}
class Department extends Party {
    get totalAnnualCost(){
        return this.monthlyCost * 12;
    }
}
```

两个函数都引用了monthltCost属性，首先改变函数声明

```javascript
class Employee extends Party {
    get annualCost(){
        return this.monthlyCost * 12;
    }
}
class Department extends Party {
    get annualCost(){
        return this.monthlyCost * 12;
    }
}
```

然后将其中一个子类的函数复制到超类中

```javascript
class Party {
    get annualCost(){
        return this.monthlyCost * 12;
    }    
}
```

## 12.2 字段上移（Pull Up Field）

1. 名称

2. 一个简单的速写

```javascript
class Employee {}
class Salesman extends Employee {
    private String name;
}
class Engineer extends Employee {
    private String name;
}
```

重构为：

```javascript
class Employee {
    protected String name;
}
class Salesman extends Employee {...}
class Engineer extends Employee {...}
```

3. 动机

首先它取出了重复的数据声明；其次它使我可以将使用该字段的行为从子类移至超类，从而去除重复的行为

4. 做法

- 针对待提升之字段，检查它们的所有使用点，确认它们以同样的方式被使用
- 如果这些字段的名称不同，先使用变量改名为它们取个相同的名字
- 在超类中新建一个字段
- 移除子类中的字段
- 测试

5. 范例

## 12.3 构造函数本体上移（Pull Up Constructor Body）

1. 名称

2. 一个简单的速写

  ```javascript
  class Party {...}
  class Employee extends Party {
      constructor(name, id, monthlyCost){
          super();
          this._id = id;
          this._name = name;
          this,_monthlyCost = monthlyCost;
      }
  }
  ```

重构为：

```javascript
class Party {
    constructor(name){
        this._name = name;
    }
}
class Employee extends Party {
    constructor(name, id, monthlyCost){
        super(name);
        this._name = name;
        this,_monthlyCost = monthlyCost;
    }
}
```

3. 动机

4. 做法

- 如果超类还不存在构造函数，首先为其定义一个。确保让子类调用超类的构造函数
- 使用移动语句将子类中构造函数中的公共语句移动到超类的构造函数调用语句之后
- 逐一移除子类间的公共代码，将其提升至超类构造函数中。对于公共代码中引用到的变量，将其作为参数传递给吵了的构造函数
- 测试
- 如果存在无法简单提升至超类的公共代码，先应用提炼函数，再利用函数上移提升之

5. 范例

- 范例一：

```javascript
class Party{}
class Employee extends Party {
    constructor(name, id, monthlyCost){
        super();
        this._id = id;
        this._name = name;
        this,_monthlyCost = monthlyCost;
    }
}
class Department extends Party {
    constructor(name, staff){
        super();
        this._name = name;
        this._staff = staff;
    }
}
```

先用移动语句将Employee中的赋值语句移动到super()调用后面

```javascript
class Employee extends Party {
    constructor(name, id, monthlyCost){
        super();
        this._name = name;
        this._id = id;
        this,_monthlyCost = monthlyCost;
    }
}
```

在超类中使用构造函数，并将name作为参数传递

```javascript
class Party{
    constructor(name){
        this._name = name;
	}
}
class Employee extends Party {
    constructor(name, id, monthlyCost){
        super(name);
        this._id = id;
        this,_monthlyCost = monthlyCost;
    }
}
class Department extends Party {
    constructor(name, staff){
        super(name);
        this._staff = staff;
    }
}
```

- 范例二

```javascript
class Employee {
    constructor(name){...}
    get isPrivileged(){...}
    assignCar(){...}
}
class Manager extends Employee {
    constructor(name, grade){
        super(name);
        this._grade = grade;
        if (this.isPrivileged) this.assignCar();
    }
    get isPrivileged(){
        return this._grade > 4;
    }
}
```

无法简单的将isPrivileged提升至超类，先对公共代码使用提炼函数

```javascript
class Manager extends Employee {
	constructor(name, grade){
        super(name);
        this._grade = grade;
        this.finishConstruction();
    }
    get isPrivileged(){
        return this._grade > 4;
    }
    finishConstruction(){
        if (this.isPrivileged) this.assignCar();
    }
} 
```

然后将提炼得到的函数上移至超类

```javascript
class Employee {
    constructor(name){...}
    get isPrivileged(){...}
    assignCar(){...}
    finishConstruction(){
        if (this.isPrivileged) this.assignCar();
    }
}
```

## 12.4 函数下移（Push Down Method）

1. 名称

2. 一个简单的速写

```javascript
class Employee {
    get quota {...}
}
class Engineer extends Employee {...}
class Salesman extends Employee {...}
```

重构为：

```javascript
class Employee {...}
class Engineer extends Employee {...}
class Salesman extends Employee {
	get quota {...}
}
```

3. 动机

如果超类中的某个函数只与一个或少数几个子类有关，那么最好将其从超类中挪走，放到真正关心它的子类中去。

4. 做法

- 将超类中的函数本体复制到每一个需要此函数的子类中
- 删除超类中的函数
- 测试
- 将该函数从所有不需要它的那些子类中删除
- 测试

5. 范例

## 12.5 字段下移（Push Down Field）

1. 名称

2. 一个简单的速写

```javascript
class Employee {
    private String quota;
}
class Engineer extends Employee {...}
class Salesman extends Emoloyee {...}
```

重构为：

```javascript
class Employee {...}
class Engineer extends Employee {...}
class Salesman extends Employee {
    protected String quota;
}
```

3. 动机

如果某个字段只被一个或少数几个子类用到，就将其搬移到需要该字段的子类中

4. 做法

- 在所有需要该字段的子类中声明该字段
- 将该字段从超类中移除
- 测试
- 将该字段从所有不需要它的那些子类中删掉
- 测试

5. 范例

## 12.6 以子类取代类型码（Replace Type Code with Subclasses）

1. 名称

2. 一个简单的速写

```javascript
function createEmployee(name, type){
    return new Employee(name, type);
}
```

重构为：

```javascript
function createEmployee(name, type){
    switch (type) {
        case "engineer": return new Engineer(name);
        case "salesman": return new Salesman(name):
        case "manager": return new Manager(name);
    }
}
```

3. 动机

应该直接处理携带类型码这个类，还是应该处理类型码本身？？？

4. 做法

- 自封装类型码字段
- 任选一个类型码取值，为其创建一个子类。覆写类型码类的取值函数，令其返回该类型码的字面量值
- 创建一个选择器逻辑，把类型码参数映射到新的子类
- 测试
- 针对每个类型码取值，重复上述“创建子类，添加选择器逻辑”的过程。每次修改后执行测试
- 去除类型码字段
- 测试
- 使用函数下移和以多态取代条件表达式处理原本访问了类型码的函数。全部处理完成之后，就可以移除类型码的访问函数。

5. 范例

- 范例一：

```javascript
class Employee {
    constructor(name, type){
        this.validateType(type);
        this._name = name;
        this._type = type;
    }
    validateType(arg) {
        if (!["engineer", "manager", "salesman"].includes(arg))
            throw new Error(`Employee connot be of type ${arg}`);
    }
    toString(){return `${this._name} (${this._type})`;}
}
```

使用封装变量将类型码自封装起来

```javascript
class Employee {
    constructor(name, type){
        this.validateType(type);
        this._name = name;
        this._type = type;
    }
    validateType(arg) {
        if (!["engineer", "manager", "salesman"].includes(arg))
            throw new Error(`Employee connot be of type ${arg}`);
    }
    get type(){return this._type;}
    toString(){return `${this._name} (${this.type})`;}
}
```

先从"engineer"开始

```javascript
class Engineer extends Employee{
    get type(){return "engineer";}
}
```

先用工厂函数取代构造函数，新建工厂函数

```javascript
function createEmployee(name, type){
    return new Employee(name, type);
}
```

然后把选择器逻辑放入工厂函数

```javascript
function createEmployee(name, type){
    switch(type){
        case "engineer": return new Engineer(name, type);
    }
    return new Employee(name, type);
}
```

处理其余的类型

```javascript
class Salesman extends Employee {
    get type(){return "salesman";}
}
class Manager extends Employee {
    get type(){return "manager";}
}
function createEmployee(name, type){
    switch(type){
        case "engineer": return new Engineer(name, type);
        case "salesman": return new Salesman(name, type):
        case "manager": return new Manager(name, type);
    }
    return new Employee(name, type);
}
```

去掉类型码字段和超类中的取值函数

```javascript
class Employee {
    constructor(name, type){
        this.validateType(type);
        this._name = name;
    }
    validateType(arg) {
        if (!["engineer", "manager", "salesman"].includes(arg))
            throw new Error(`Employee connot be of type ${arg}`);
    }
    toString(){return `${this._name} (${this.type})`;}
}
```

移除验证逻辑

```javascript
class Employee {
    constructor(name, type){
        this._name = name;
    }
    toString(){return `${this._name} (${this.type})`;}
}
function createEmployee(name, type){
    switch(type){
        case "engineer": return new Engineer(name, type);
        case "salesman": return new Salesman(name, type):
        case "manager": return new Manager(name, type);
        default: throw new Error(`Employee connot be of type ${type}`);
    }
}
```

修噶函数声明，去除类型码

```javascript
class Employee {
    constructor(name){
        this._name = name;
    }
    toString(){return `${this._name} (${this.type})`;}
}
function createEmployee(name, type){
    switch(type){
        case "engineer": return new Engineer(name);
        case "salesman": return new Salesman(name):
        case "manager": return new Manager(name);
        default: throw new Error(`Employee connot be of type ${type}`);
    }
}
class Engineer extends Employee{
    get type(){return "engineer";}
}
class Salesman extends Employee {
    get type(){return "salesman";}
}
class Manager extends Employee {
    get type(){return "manager";}
}
```

- 范例二：使用间接继承

```javascript
class Employee {
    constructor(name, type){
        this.validateType(type);
        this._name = name;
        this._type = type;
    }
    validateType(arg) {
        if (!["engineer", "manager", "salesman"].includes(arg))
            throw new Error(`Employee connot be of type ${arg}`);
    }
    get type(){return this._type;}
    set type(arg){this._type = arg;}
    get capitalizedType(){
        return this._type.charAt(0).toUpperCase() + this._type.substr(1).toLowerCase();
    }
    toString(){return `${this._name} (${this.capitalizedType})`;}
}
```

首先以对象取代基本类型包装类型码

```javascript
class EmployeeType {
    constructor(aString){
        this._value = aString;
    }
    toString(){return this._value;}
}
class Employee {
    constructor(name, type){
        this.validateType(type);
        this._name = name;
        this.type = type;
    }
    validateType(arg) {
        if (!["engineer", "manager", "salesman"].includes(arg))
            throw new Error(`Employee connot be of type ${arg}`);
    }
    get typeString(){return this._type.toString();}
    get type(){return this._type;}
    set type(arg){this._type = new EmployeeType(arg);}
    get capitalizedType(){
        return this.typeString.charAt(0).toUpperCase() + this.typeString.substr(1).toLowerCase();
    }
    toString(){return `${this._name} (${this.capitalizedType})`;}
}
```

然后以子类取代类型码

```javascript
class Employee {
    constructor(name, type){
        this.validateType(type);
        this._name = name;
        this.type = type;
    }
    validateType(arg) {
        if (!["engineer", "manager", "salesman"].includes(arg))
            throw new Error(`Employee connot be of type ${arg}`);
    }
    get typeString(){return this._type.toString();}
    get type(){return this._type;}
    set type(arg){this._type = Employee.createEmployeeType(arg);}
    static createEmployeeType(aString){
        switch(aString){
            case "engineer": return new Engineer();
            case "manager": return new Manager();
            case "salesman": return new Salesman();
            default:throw new Error(`Employee connot be of type ${aString}`);
        }
    }
    get capitalizedType(){
        return this.typeString.charAt(0).toUpperCase() + this.typeString.substr(1).toLowerCase();
    }
    toString(){return `${this._name} (${this.type.capitalizedName})`;}
}
class EmployeeType {
     get capitalizedName(){
        return this.toString.charAt(0).toUpperCase() + this.toString.substr(1).toLowerCase();
    }
}
class Engineer extends EmployeeType {
    toString(){return "engineer";}
}
class Manager extends EmployeeType {
    toString(){return "manager";}
}
class Salesman extends EmployeeType {
    toString(){return "salesman";}
}
```

## 12.7 移除子类（Remove Subclass）

1. 名称

2. 一个简单的速写

```javascript
class Person {
    get genderCode(){return "X";}
}
class Male extends Person {
    get genderCode(){return "M";}
}
c;ass Female extends Person {
    get genderCode(){return "F";}
}
```

重构为：

```javascript
class Person {
    get genderCode(){return this._genderCode;}
}
```

3. 动机

4. 做法

- 使用以工厂函数渠道构造函数，把子类的构造函数包装到超类的工厂函数中
- 如果有任何代码检查子类的类型，先用提炼函数把类型检查逻辑包装起来，然后用搬移函数将其搬移到超类。每次修改后执行测试
- 新建一个字段，用于代表子类的类型
- 将原本针对子类的类型做判断的函数改为使用新建的类型字段
- 删除子类
- 测试

5. 范例

```javascript
class Person {
    constructor(name){
        this._name = name;
    }
    get name(){return this._name;}
    get genderCode() {return "X";}
}
class Male extends Person {
    get genderCode(){return "M";}
}
c;ass Female extends Person {
    get genderCode(){return "F";}
}
const numberOfMales = people.filter(p => p instanceof Male).length;
```

先使用提炼函数把“选择哪个类来实例化”的逻辑提炼成工厂函数

```javascript
function createPerson(aRecord){
    let p;
    switch (aRecord.gender){
        case 'M': p = new Male(aRecord.name);break;
        case 'F': p = new Female(aRecord.name);break;
        default: p = new Person(sRecord.name);
    }
    return p;
}
function loadFromInput(data){
    const result = [];
    data.forEach(aRecord => {
        result.push(createPerson(aRecord));
    });
    return result;
}
```

使用内联变量简化工厂函数，使用管道简化loadFromInput函数

```javascript
function createPerson(aRecord){
    switch (aRecord.gender){
        case 'M': return new Male(aRecord.name);
        case 'F': return new Female(aRecord.name);
        default: return new Person(sRecord.name);
    }
}
function loadFromInput(data){
    return data.map(aRecord => createPerson(aRecord));
}
const numberOfMales = people.filter(p => p  isMale(p)).length;
function isMale(aPerson){return aPerson instanceof Male;}
```

然后使用搬移函数将客户端搬移到Person类

```javascript
class Person{
    get isMale() {return this instanceof Male;}
}
const numberOfMales = people.filter(p => p.isMale).length;
```

Person类中添加一个字段来表示子类之间的差异

```javascript
class Person {
    constructor(name, genderCOde){
        this._name = name;
        this._genderCode = genderCode || "X";
    }
    get name(){return this._name;}
    get genderCode() {return this._genderCode;}
    get isMale() {return "M" === this._grandeCode;}
}
```

工厂函数添加对应的参数

```javascript
function createPerson(aRecord){
    switch (aRecord.gender){
        case 'M': return new Male(aRecord.name, 'M');
        case 'F': return new Female(aRecord.name, 'F');
        default: return new Person(sRecord.name, 'X');
    }
}
```

## 12.8 提炼超类（Extract Superclass）

1. 名称

2. 一个简单的速写

```javascript
class Department {
    get totalAnnualCost(){...}
    get name(){...}
    get headCount(){...}
}
class Employee {
   get annualCost(){...}
   get name(){...}
   get id(){...}
}
```

重构为：

```javascript
class Party {
    get name(){...}
    get annualCost(){...}
}
class Department extends Party {
    get annualCost(){...}
    get headCount(){...}
}
class Employee extends Party {
    get annualCost(){...}
    get id(){...}
}
```

3. 动机

如果两个类在做相似的事，可以利用基本的继承机制把它们的相似指出提炼到超类

4. 做法

- 为原本的类新建一个空白的超类
- 测试
- 使用构造函数本体上移、函数上移和字段上移手法，逐一将子类的共同元素上移到超类
- 检查留在子类中的函数，看它们是否还有共同的成分。如果有，可以先用提炼函数将其提炼出来，再用函数上移搬到超类
- 检查所有使用原本的类的客户端代码，考虑将其调整为使用超类的接口

5. 范例

```javascript
class Empliyee {
    constructor(name, id, monthlyCost){
        this._id = id;
        this._name = name;
        this._monthlyCost = monthlyCost;
    }
    get monthlyCost(){return this._monthlyCost;}
    get name(){return this._name;}
    get id(){return this._id;}
    get annualCost(){return this.monthlyCost * 12;}
}
class Department {
    constructor(name, staff){
        this._name = name;
        this._staff = staff;
    }
    get staff(){return this._staff;}
    get name(){return this._name;}
    get totalMonthlyCost(){
        return this.staff
            .map(e => e.monthlyCost)
            .reduce((sum, cost) => sum + cost);
    }
    get headCount(){return this.staff.length;}
    get totalAnnualCost(){return this.totalMonthlyCost * 12;}
}
```

首先创建一个空的超类，让原来的两个类都继承这个新的类

```javascript
class Party {}
class Empliyee extends Party {
    constructor(name, id, monthlyCost){
        super();
        this._id = id;
        this._name = name;
        this._monthlyCost = monthlyCost;
    }
    get monthlyCost(){return this._monthlyCost;}
    get name(){return this._name;}
    get id(){return this._id;}
    get annualCost(){return this.monthlyCost * 12;}
}
class Department extends Party {
    constructor(name, staff){
        super();
        this._name = name;
        this._staff = staff;
    }
    get staff(){return this._staff;}
    get name(){return this._name;}
    get totalMonthlyCost(){
        return this.staff
            .map(e => e.monthlyCost)
            .reduce((sum, cost) => sum + cost);
    }
    get headCount(){return this.staff.length;}
    get totalAnnualCost(){return this.totalMonthlyCost * 12;}
}
```

用上移字段把name搬到超类中

```javascript
class Party {
    constructor(name){
        this._name = name;
    }
}
class Empliyee extends Party {
    constructor(name, id, monthlyCost){
        super(name);
        this._id = id;
        this._monthlyCost = monthlyCost;
    }
    get monthlyCost(){return this._monthlyCost;}
    get name(){return this._name;}
    get id(){return this._id;}
    get annualCost(){return this.monthlyCost * 12;}
}
class Department extends Party {
    constructor(name, staff){
        super(name);
        this._staff = staff;
    }
    get staff(){return this._staff;}
    get name(){return this._name;}
    get totalMonthlyCost(){
        return this.staff
            .map(e => e.monthlyCost)
            .reduce((sum, cost) => sum + cost);
    }
    get headCount(){return this.staff.length;}
    get totalAnnualCost(){return this.totalMonthlyCost * 12;}
}
```

用函数上移把相关的函数也搬移到超类

```javascript
class Party {
    constructor(name){
        this._name = name;
    }
    get name(){return this._name;}
}
class Empliyee extends Party {
    constructor(name, id, monthlyCost){
        super(name);
        this._id = id;
        this._monthlyCost = monthlyCost;
    }
    get monthlyCost(){return this._monthlyCost;}
    get name(){return this._name;}
    get id(){return this._id;}
    get annualCost(){return this.monthlyCost * 12;}
}
class Department extends Party {
    constructor(name, staff){
        super(name);
        this._staff = staff;
    }
    get staff(){return this._staff;}
    get name(){return this._name;}
    get totalMonthlyCost(){
        return this.staff
            .map(e => e.monthlyCost)
            .reduce((sum, cost) => sum + cost);
    }
    get headCount(){return this.staff.length;}
    get totalAnnualCost(){return this.totalMonthlyCost * 12;}
}
```

把两个函数体相似的函数进行改变函数声明

```javascript
class Party {
    constructor(name){
        this._name = name;
    }
    get name(){return this._name;}
}
class Empliyee extends Party {
    constructor(name, id, monthlyCost){
        super(name);
        this._id = id;
        this._monthlyCost = monthlyCost;
    }
    get monthlyCost(){return this._monthlyCost;}
    get name(){return this._name;}
    get id(){return this._id;}
    get annualCost(){return this.monthlyCost * 12;}
}
class Department extends Party {
    constructor(name, staff){
        super(name);
        this._staff = staff;
    }
    get staff(){return this._staff;}
    get name(){return this._name;}
    get monthlyCost(){
        return this.staff
            .map(e => e.monthlyCost)
            .reduce((sum, cost) => sum + cost);
    }
    get headCount(){return this.staff.length;}
    get annualCost(){return this.monthlyCost * 12;}
}
```

然后将函数搬移到超类中

```javascript
class Party {
    constructor(name){
        this._name = name;
    }
    get name(){return this._name;}
	get annualCost(){return this.monthlyCost * 12;}
}
class Empliyee extends Party {
    constructor(name, id, monthlyCost){
        super(name);
        this._id = id;
        this._monthlyCost = monthlyCost;
    }
    get monthlyCost(){return this._monthlyCost;}
    get id(){return this._id;}
}
class Department extends Party {
    constructor(name, staff){
        super(name);
        this._staff = staff;
    }
    get staff(){return this._staff;}
    get monthlyCost(){
        return this.staff
            .map(e => e.monthlyCost)
            .reduce((sum, cost) => sum + cost);
    }
    get headCount(){return this.staff.length;}
}
```























